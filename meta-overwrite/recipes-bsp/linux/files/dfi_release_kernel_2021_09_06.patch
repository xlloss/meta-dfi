diff --git a/arch/arm64/boot/dts/freescale/Makefile b/arch/arm64/boot/dts/freescale/Makefile
index d5eb439fe..69482643f 100644
--- a/arch/arm64/boot/dts/freescale/Makefile
+++ b/arch/arm64/boot/dts/freescale/Makefile
@@ -64,7 +64,7 @@ dtb-$(CONFIG_ARCH_MXC) += imx8mn-ab2.dtb imx8mn-ddr4-ab2.dtb
 dtb-$(CONFIG_ARCH_MXC) += imx8mp-evk.dtb imx8mp-evk-root.dtb imx8mp-evk-inmate.dtb imx8mp-evk-rpmsg.dtb \
 			  imx8mp-evk-rm67191.dtb imx8mp-evk-flexcan2.dtb imx8mp-evk-it6263-lvds-dual-channel.dtb \
 			  imx8mp-evk-jdi-wuxga-lvds-panel.dtb imx8mp-ab2.dtb imx8mp-evk-sof-wm8960.dtb \
-			  imx8mp-evk-dsp.dtb imx8mp-evk-ov2775.dtb imx8mp-evk-basler.dtb
+			  imx8mp-evk-dsp.dtb imx8mp-evk-ov2775.dtb imx8mp-evk-basler.dtb imx8mp-m8mp553.dtb
 dtb-$(CONFIG_ARCH_MXC) += imx8mq-evk.dtb imx8mq-evk-rpmsg.dtb imx8mq-evk-pcie1-m2.dtb imx8mq-evk-usd-wifi.dtb \
 			  imx8mq-evk-usdhc2-m2.dtb
 dtb-$(CONFIG_ARCH_MXC) += imx8mq-evk-ak4497.dtb imx8mq-evk-audio-tdm.dtb imx8mq-evk-pdm.dtb
diff --git a/arch/arm64/boot/dts/freescale/imx8mp-m8mp553.dts b/arch/arm64/boot/dts/freescale/imx8mp-m8mp553.dts
new file mode 100644
index 000000000..917fabc53
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/imx8mp-m8mp553.dts
@@ -0,0 +1,1411 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright 2021 DFI
+ */
+
+/dts-v1/;
+
+#include <dt-bindings/usb/pd.h>
+#include "imx8mp.dtsi"
+
+/ {
+	model = "DFI M8MP553 Board";
+	compatible = "fsl,imx8mp-evk", "fsl,imx8mp";
+
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		rpmsg_reserved: rpmsg@0x55800000 {
+			no-map;
+			reg = <0 0x55800000 0 0x800000>;
+		};
+	};
+
+	chosen {
+		stdout-path = &uart2;
+	};
+
+	reg_can1_stby: regulator-can1-stby {
+		status = "disabled";
+		compatible = "regulator-fixed";
+		regulator-name = "can1-stby";
+		pinctrl-names = "default";
+		/* pinctrl-0 = <&pinctrl_flexcan1_reg>; */
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		gpio = <&gpio5 5 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+	};
+
+	reg_usdhc2_vmmc: regulator-usdhc2 {
+		compatible = "regulator-fixed";
+		regulator-name = "VSD_3V3";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		gpio = <&gpio2 19 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		startup-delay-us = <100>;
+		off-on-delay-us = <12000>;
+	};
+
+	reg_gpio_sd: regulator-sd {
+			compatible = "regulator-gpio";
+			pinctrl-names = "default";
+			pinctrl-0 = <&pinctrl_sd_en>;
+			regulator-min-microvolt = <0000001>;
+			regulator-max-microvolt = <3300000>;
+			regulator-name = "gpio_sd";
+			regulator-type = "voltage";
+			gpios = <&gpio2 8 GPIO_ACTIVE_LOW>;
+			gpios-states = <1>;
+			states = <3300000 0x1 0000000 0x0>;
+	};
+
+	reg_gpio_usb_hub: regulator-usb_hub {
+			compatible = "regulator-gpio";
+			pinctrl-names = "default";
+			pinctrl-0 = <&pinctrl_usb_hub_en>;
+			regulator-min-microvolt = <0000001>;
+			regulator-max-microvolt = <3300000>;
+			regulator-name = "gpio_usb_hub";
+			regulator-type = "voltage";
+			gpios = <&gpio3 25 GPIO_ACTIVE_LOW>;
+			gpios-states = <1>;
+			states = <3300000 0x1 0000000 0x0>;
+	};
+
+	reg_gpio_usb3_typea: regulator-usb3-typea {
+			compatible = "regulator-gpio";
+			pinctrl-names = "default";
+			pinctrl-0 = <&pinctrl_usb3_typea_en>;
+			regulator-min-microvolt = <0000001>;
+			regulator-max-microvolt = <3300000>;
+			regulator-name = "gpio_usb3_typea";
+			regulator-type = "voltage";
+			gpios = <&gpio3 22 GPIO_ACTIVE_LOW>;
+			gpios-states = <1>;
+			states = <3300000 0x1 0000000 0x0>;
+	};
+
+	reg_gpio_usb2_typea: regulator-usb2-typea {
+			compatible = "regulator-gpio";
+			pinctrl-names = "default";
+			pinctrl-0 = <&pinctrl_usb2_typea_en>;
+			regulator-min-microvolt = <0000001>;
+			regulator-max-microvolt = <3300000>;
+			regulator-name = "gpio_usb2_typea";
+			regulator-type = "voltage";
+			gpios = <&gpio3 23 GPIO_ACTIVE_LOW>;
+			gpios-states = <1>;
+			states = <3300000 0x1 0000000 0x0>;
+	};
+
+	reg_gpio_usb2_hdr: regulator-usb2-hdr {
+			compatible = "regulator-gpio";
+			pinctrl-names = "default";
+			pinctrl-0 = <&pinctrl_usb2_hdr_en>;
+			regulator-min-microvolt = <0000001>;
+			regulator-max-microvolt = <3300000>;
+			regulator-name = "gpio_usb2_hdr";
+			regulator-type = "voltage";
+			gpios = <&gpio3 24 GPIO_ACTIVE_LOW>;
+			gpios-states = <1>;
+			states = <3300000 0x1 0000000 0x0>;
+	};
+
+	reg_gpio_usb2_otg: regulator-usb2-otg {
+			compatible = "regulator-gpio";
+			pinctrl-names = "default";
+			pinctrl-0 = <&pinctrl_usb2_otg_en>;
+			regulator-min-microvolt = <0000001>;
+			regulator-max-microvolt = <3300000>;
+			regulator-name = "gpio_usb2_otg";
+			regulator-type = "voltage";
+			gpios = <&gpio3 21 GPIO_ACTIVE_LOW>;
+			gpios-states = <1>;
+			states = <3300000 0x1 0000000 0x0>;
+	};
+
+	reg_lvds_panel: regulator-reg_lvds_panel {
+		compatible = "regulator-gpio";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_panel_pwr_en>;
+		regulator-min-microvolt = <0000001>;
+		regulator-max-microvolt = <3300000>;
+		regulator-name = "lvds_panel_pwr";
+		regulator-type = "voltage";
+		gpios = <&gpio1 0 GPIO_ACTIVE_HIGH>;
+		gpios-states = <0>;
+		states = <3300000 0x1 0000001 0x0>;
+		status = "okay";
+	};
+
+	reg_com_pwr: regulator-reg_com_pwr {
+		compatible = "regulator-gpio";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_com_pwr_en>;
+		regulator-min-microvolt = <0000001>;
+		regulator-max-microvolt = <3300000>;
+		regulator-name = "com_pwr_en";
+		regulator-type = "voltage";
+		gpios = <&gpio2 9 GPIO_ACTIVE_HIGH>;
+		gpios-states = <1>;
+		states = <3300000 0x1 0000001 0x0>;
+		status = "okay";
+	};
+
+	reg_audio_vdda: regulator-audio_vdda {
+		compatible = "regulator-fixed";
+		regulator-name = "fixed-3.3V";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-boot-on;
+		regulator-always-on;
+	};
+
+	reg_audio_vddio: regulator-audio_vddio {
+		compatible = "regulator-fixed";
+		regulator-name = "fixed-3.3V";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-boot-on;
+		regulator-always-on;
+	};
+
+	reg_audio_vddd: regulator-audio_vddd {
+		compatible = "regulator-fixed";
+		regulator-name = "fixed-1.8V";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		regulator-boot-on;
+		regulator-always-on;
+	};
+
+	reg_keyb_pwr: regulator-reg_keyb_pwr {
+		compatible = "regulator-gpio";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_keyb_pwr_en>;
+		regulator-min-microvolt = <0000001>;
+		regulator-max-microvolt = <3300000>;
+		regulator-name = "keyb_pwr_en";
+		regulator-type = "voltage";
+		gpios = <&gpio1 11 GPIO_ACTIVE_HIGH>;
+		gpios-states = <1>;
+		states = <3300000 0x1 0000001 0x0>;
+		status = "okay";
+	};
+
+	reg_keyb_rst: regulator-reg_keyb_rst {
+		compatible = "regulator-gpio";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_keyb_rst_en>;
+		regulator-min-microvolt = <0000001>;
+		regulator-max-microvolt = <3300000>;
+		regulator-name = "keyb_rst_en";
+		regulator-type = "voltage";
+		gpios = <&gpio1 5 GPIO_ACTIVE_HIGH>;
+		gpios-states = <1>;
+		states = <3300000 0x1 0000001 0x0>;
+		status = "okay";
+	};
+
+	reg_eqos_rst: regulator-reg_eqos_rst {
+		compatible = "regulator-gpio";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_eqos_rst_en>;
+		regulator-min-microvolt = <0000001>;
+		regulator-max-microvolt = <3300000>;
+		regulator-name = "eqos_rst_en";
+		regulator-type = "voltage";
+		gpios = <&gpio4 0 GPIO_ACTIVE_HIGH>;
+		gpios-states = <1>;
+		states = <3300000 0x1 0000001 0x0>;
+		status = "okay";
+	};
+
+	reg_fec_rst: regulator-reg_fec_rst {
+		compatible = "regulator-gpio";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_fec_rst_en>;
+		regulator-min-microvolt = <0000001>;
+		regulator-max-microvolt = <3300000>;
+		regulator-name = "fec_rst_en";
+		regulator-type = "voltage";
+		gpios = <&gpio4 2 GPIO_ACTIVE_HIGH>;
+		gpios-states = <1>;
+		states = <3300000 0x1 0000001 0x0>;
+		status = "okay";
+	};
+
+	panel-lvds0 {
+		compatible = "panel-lvds";
+		status = "okay";
+		width-mm = <261>;
+		height-mm = <163>;
+		data-mapping = "jeida-24";
+
+		backlight = <&lvds_backlight>;
+		power-supply = <&reg_lvds_panel>;
+		backlight-delay = <0>;
+
+		panel-timing {
+			/* 1024x600 @60Hz : AM-1024600DTZQW-TD1H */
+			clock-frequency = <51000000>;
+			hactive = <1024>;
+			vactive = <600>;
+			hsync-len = <10>;
+			hfront-porch = <160>;
+			hback-porch = <160>;
+			vsync-len = <5>;
+			vfront-porch = <12>;
+			vback-porch = <23>;
+		};
+
+		port {
+			panel_lvds0_in: endpoint {
+				remote-endpoint = <&lvds0_port_1>;
+			};
+		};
+	};
+
+	lvds_backlight: lvds_backlight {
+		compatible = "pwm-backlight";
+		pwms = <&pwm2 0 100000>; /* 10KHz*/
+		status = "okay";
+		pinctrl-0 = <&pinctrl_backlight_en>, <&pinctrl_backlight_pwm2>;
+		enable-gpios = <&gpio1 1 GPIO_ACTIVE_HIGH>;
+		brightness-levels = < 0  1  2  3  4  5  6  7  8  9
+				     10 11 12 13 14 15 16 17 18 19
+				     20 21 22 23 24 25 26 27 28 29
+				     30 31 32 33 34 35 36 37 38 39
+				     40 41 42 43 44 45 46 47 48 49
+				     50 51 52 53 54 55 56 57 58 59
+				     60 61 62 63 64 65 66 67 68 69
+				     70 71 72 73 74 75 76 77 78 79
+				     80 81 82 83 84 85 86 87 88 89
+				     90 91 92 93 94 95 96 97 98 99
+				    100>;
+		default-brightness-level = <80>;
+	};
+
+	leds {
+		compatible = "gpio-leds";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_sys_led> , <&pinctrl_dbg_led>;
+
+		led_sys: led_sys {
+			label = "led_sys";
+			gpios = <&gpio3 16 GPIO_ACTIVE_HIGH>;
+			default-state = "on";
+			linux,default-trigger = "gpio";
+		};
+
+		led_dbg: led_dbg {
+			label = "led_dbg";
+			gpios = <&gpio3 6 GPIO_ACTIVE_HIGH>;
+			default-state = "on";
+			linux,default-trigger = "heartbeat";
+		};
+
+	};
+
+	videopllsscm: videopll_sscm@30360034 {
+		compatible = "fsl,imx8mp-videopll-sscm";
+		reg = <0 0x30360034 0 0x1000>;
+		clocks = <&clk IMX8MP_VIDEO_PLL1>;
+		clock-names = "video_pll1";
+
+		/*
+		  MF: 125000Hz
+		  MR: 3.1%
+		*/
+		mf = <125000>;
+		mr = <310>;
+		pf = <2>;
+	};
+
+	/* mode select
+	 * {"rs422-full"},
+	 * {"pure-rs232"},
+	 * {"rs485-half tx-en low act"},
+	 * {"rs485-half tx-en hi  act"},
+	 * {"rs422-full with termi bias resistor"},
+	 * {"pure-rs232 co-exists rs485"},
+	 * {"rs485-half with termi bias resistor"},
+	 * {"shutdown"},
+	 */
+	f81439_ctl: f81439_ctl@0 {
+		compatible = "fintek, f81439";
+		pinctrl-0 = <&pinctrl_f81439>;
+		default-mode = "pure-rs232";
+		mode0-gpios = <&gpio4 25 GPIO_ACTIVE_HIGH>;
+		mode1-gpios = <&gpio4 26 GPIO_ACTIVE_HIGH>;
+		mode2-gpios = <&gpio4 27 GPIO_ACTIVE_HIGH>;
+	};
+
+	sound {
+		compatible = "simple-audio-card";
+		simple-audio-card,name = "sgtl5000";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,convert-rate = <48000>;
+
+		simple-audio-card,bitclock-master = <&dailink0_master>;
+		simple-audio-card,frame-master = <&dailink0_master>;
+
+		simple-audio-card,widgets =
+			"Microphone", "Microphone Jack",
+			"Headphone", "Headphone Jack",
+			"Speaker", "Speaker Ext",
+			"Line", "Line In Jack";
+
+		simple-audio-card,routing =
+			"MIC_IN", "Microphone Jack",
+			"Microphone Jack", "Mic Bias",
+			"LINE_IN", "Line In Jack",
+			"Headphone Jack", "HP_OUT",
+			"Speaker Ext", "LINE_OUT",
+			"Playback", "AIFIN",
+			"AIFOUT", "Capture";
+
+		simple-audio-card,cpu {
+			#sound-dai-cells = <0>;
+			sound-dai = <&sai3>;
+		};
+
+		dailink0_master: simple-audio-card,codec {
+			sound-dai = <&sgtl5000>;
+			clocks = <&audiomix_clk IMX8MP_CLK_AUDIOMIX_SAI3_MCLK1>;
+		};
+	};
+
+	xhci_otg_sw: xhci_otg_sw {
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_otg_sw>;
+		compatible = "dfi, otg-sw";
+		role-gpios = <&gpio1 10 GPIO_ACTIVE_HIGH>;
+
+		usb_con: connector {
+			port {
+				otg_sw: endpoint {
+					remote-endpoint = <&usb3_drd_sw>;
+				};
+			};
+		};
+
+	};
+};
+
+&clk {
+	init-on-array = <IMX8MP_CLK_HSIO_ROOT>;
+};
+
+&A53_0 {
+	cpu-supply = <&buck2_reg>;
+};
+
+/* IOJP1 */
+&pwm3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm3>;
+	status = "okay";
+};
+
+/* buzzer use */
+&pwm1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_buzzer>;
+	status = "okay";
+};
+
+/* backlight use */
+&pwm2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_backlight_pwm2>;
+	status = "okay";
+};
+
+&ecspi1 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	fsl,spi-num-chipselects = <1>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ecspi1 &pinctrl_ecspi1_cs>;
+	status = "okay";
+
+	spidev0: spi@0 {
+		status = "okay";
+		reg = <0>;
+		compatible = "rohm,dh2228fv";
+		spi-max-frequency = <500000>;
+	};
+};
+
+&eqos {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_eqos>;
+	phy-mode = "rgmii-id";
+	phy-handle = <&ethphy0>;
+	stmmc-disable-dma-swrst;
+	status = "okay";
+
+	mdio {
+		compatible = "snps,dwmac-mdio";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		ethphy0: ethernet-phy@1 {
+			compatible = "ethernet-phy-ieee802.3-c22";
+			reg = <7>;
+			eee-broken-1000t;
+		};
+	};
+};
+
+&fec {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_fec>;
+	phy-mode = "rgmii-id";
+	phy-handle = <&ethphy1>;
+	fsl,magic-packet;
+	status = "okay";
+
+	mdio {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		ethphy1: ethernet-phy@1 {
+			compatible = "ethernet-phy-ieee802.3-c22";
+			reg = <5>;
+			eee-broken-1000t;
+		};
+	};
+};
+
+&i2c1 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c1>;
+	status = "okay";
+
+	pmic: pca9450@25 {
+		reg = <0x25>;
+		compatible = "nxp,pca9450";
+		/* PMIC PCA9450 PMIC_nINT GPIO1_IO3 */
+		pinctrl-0 = <&pinctrl_pmic>;
+		gpio_intr = <&gpio1 3 GPIO_ACTIVE_LOW>;
+
+		regulators {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			pca9450,pmic-buck2-uses-i2c-dvs;
+			/* Run/Standby voltage */
+			pca9450,pmic-buck2-dvs-voltage = <950000>, <850000>;
+
+			buck1_reg: regulator@0 {
+				reg = <0>;
+				regulator-compatible = "buck1";
+				regulator-min-microvolt = <600000>;
+				regulator-max-microvolt = <2187500>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <3125>;
+			};
+
+			buck2_reg: regulator@1 {
+				reg = <1>;
+				regulator-compatible = "buck2";
+				regulator-min-microvolt = <600000>;
+				regulator-max-microvolt = <2187500>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <3125>;
+			};
+
+			buck4_reg: regulator@3 {
+				reg = <3>;
+				regulator-compatible = "buck4";
+				regulator-min-microvolt = <600000>;
+				regulator-max-microvolt = <3400000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			buck5_reg: regulator@4 {
+				reg = <4>;
+				regulator-compatible = "buck5";
+				regulator-min-microvolt = <600000>;
+				regulator-max-microvolt = <3400000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			buck6_reg: regulator@5 {
+				reg = <5>;
+				regulator-compatible = "buck6";
+				regulator-min-microvolt = <600000>;
+				regulator-max-microvolt = <3400000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo1_reg: regulator@6 {
+				reg = <6>;
+				regulator-compatible = "ldo1";
+				regulator-min-microvolt = <1600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo2_reg: regulator@7 {
+				reg = <7>;
+				regulator-compatible = "ldo2";
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1150000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo3_reg: regulator@8 {
+				reg = <8>;
+				regulator-compatible = "ldo3";
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo4_reg: regulator@9 {
+				reg = <9>;
+				regulator-compatible = "ldo4";
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo5_reg: regulator@10 {
+				reg = <10>;
+				regulator-compatible = "ldo5";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+			};
+		};
+	};
+
+	lm75: board-temp-sensor@4c {
+		compatible = "national,lm75b";
+		reg = <0x4c>;
+	};
+
+	s35390a: s35390a@30 {
+		compatible = "s35390a";
+		reg = <0x30>;
+
+		/*
+		 * set INT1 pin for user set frequency
+		 *
+		 * 0  : disable
+		 * 1  : 16 Hz
+		 * 2  : 8 Hz
+		 * 4  : 4 Hz
+		 * 8  : 2 Hz
+		 * 16 : 1 Hz
+		 */
+		user-set-frequency = <16>;
+	};
+};
+
+&i2c2 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c2>;
+	status = "okay";
+
+	at24c16: eeprom@50 {
+		compatible = "atmel,24c16";
+		reg = <0x50>;
+	};
+
+	f75387: f75387@2d {
+		compatible = "f75387";
+		reg = <0x2d>;
+
+		force-pwm-mode-3;
+
+		/*
+		 * pin5 is used as Fan fault function
+
+		 * 3: LED out(1Hz/0.5Hz select by LED_FREQ register)
+		 * 2: pin5 is used as Fan fault function
+		 * 1: pin5 is used as SMI
+		 * 0: pin5 function is GPIO2.(default)
+		 */
+		pin5-mode = <2>;
+
+		/*
+		 * 3: PIN6 will function as operating clock input function.
+		 * 2: PIN6 will act as voltage fault function
+		 * 1: PIN6 will act as OVT#
+		 * 0: PIN6 will act as GPIO3.
+		 */
+		pin6-mode = <1>;
+
+		/*
+		 * bit 1: enable FAN2 fan fault mechanism
+		 * bit 0: enable FAN1 fan fault mechanism
+		 */
+		enable_fan_fault = <1>;
+
+		/*
+		 * bit 1: enable over temperature mechanism of VT2
+		 * bit 0: enable over temperature mechanism of VT1
+		 */
+		enable_temp_fault = <1>;
+	};
+
+	sgtl5000: audio-codec@a {
+		compatible = "fsl,sgtl5000";
+		#sound-dai-cells = <0>;
+		reg = <0x0a>;
+		VDDA-supply = <&reg_audio_vdda>;
+		VDDIO-supply = <&reg_audio_vddio>;
+		VDDD-supply = <&reg_audio_vddd>;
+
+		micbias-resistor-k-ohms = <2>;
+		micbias-voltage-m-volts = <1575>;
+
+		clocks = <&audiomix_clk IMX8MP_CLK_AUDIOMIX_SAI3_MCLK1>;
+		clock-names = "mclk";
+		assigned-clock-rates = <24576000>;
+	};
+};
+
+&sai3 {
+	#sound-dai-cells = <0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_sai3>;
+	assigned-clocks = <&clk IMX8MP_CLK_SAI3>;
+	assigned-clock-parents = <&clk IMX8MP_AUDIO_PLL1_OUT>;
+	assigned-clock-rates = <24576000>;
+	clocks = <&audiomix_clk IMX8MP_CLK_AUDIOMIX_SAI3_IPG>, <&clk IMX8MP_CLK_DUMMY>,
+		<&audiomix_clk IMX8MP_CLK_AUDIOMIX_SAI3_MCLK1>, <&clk IMX8MP_CLK_DUMMY>,
+		<&clk IMX8MP_CLK_DUMMY>,<&clk IMX8MP_AUDIO_PLL1_OUT>,<&clk IMX8MP_AUDIO_PLL2_OUT>;
+	clock-names = "bus", "mclk0", "mclk1", "mclk2", "mclk3", "pll8k", "pll11k";
+	fsl,sai-mclk-direction-output;
+	status = "okay";
+};
+
+&sdma2 {
+	status = "okay";
+};
+
+&easrc {
+	fsl,asrc-rate  = <44100>;
+	status = "okay";
+};
+
+&i2c3 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c3>;
+	status = "okay";
+
+	touch_panel: touch_panel@41 {
+		compatible = "ilitek,ili251x";
+		pinctrl-0 = <&pinctrl_touch_irq>, <&pinctrl_touch_rst>;
+		interrupt-parent = <&gpio2>;
+		interrupts = <10 IRQ_TYPE_LEVEL_LOW>;
+		reg = <0x41>;
+		reset-gpios = <&gpio2 11 GPIO_ACTIVE_LOW>;
+	};
+};
+
+&i2c4 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c4>;
+	status = "okay";
+};
+
+&flexcan1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexcan1>;
+	/* xceiver-supply = <&reg_can1_stby>; */
+	status = "okay";
+};
+
+&lcdif1 {
+	status = "disabled";
+};
+
+&lcdif2 {
+	status = "okay";
+};
+
+&lcdif3 {
+	status = "okay";
+};
+
+&ldb {
+	status = "okay";
+	startup-delay-us = <20>;
+	lvds-channel@0 {
+		fsl,data-mapping = "spwg";
+		fsl,data-width = <24>;
+		status = "okay";
+
+		port@1 {
+			reg = <1>;
+			lvds0_port_1: endpoint {
+					remote-endpoint = <&panel_lvds0_in>;
+			};
+		};
+	};
+};
+
+&ldb_phy {
+	status = "okay";
+};
+
+&pcie{
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pcie>;
+	disable-gpio = <&gpio1 13 GPIO_ACTIVE_LOW>;
+	reset-gpio = <&gpio1 15 GPIO_ACTIVE_LOW>;
+	ext_osc = <1>;
+	clocks = <&clk IMX8MP_CLK_HSIO_AXI_DIV>,
+		 <&clk IMX8MP_CLK_PCIE_AUX>,
+		 <&clk IMX8MP_CLK_PCIE_PHY>,
+		 <&clk IMX8MP_CLK_PCIE_ROOT>;
+	clock-names = "pcie", "pcie_aux", "pcie_phy", "pcie_bus";
+	assigned-clocks = <&clk IMX8MP_CLK_HSIO_AXI_SRC>,
+			  <&clk IMX8MP_CLK_PCIE_AUX>;
+	assigned-clock-parents = <&clk IMX8MP_SYS_PLL2_500M>,
+				 <&clk IMX8MP_SYS_PLL2_50M>;
+	reserved-region = <&rpmsg_reserved>;
+	status = "okay";
+};
+
+&pcie_phy{
+	status = "okay";
+};
+
+
+/* com1 */
+&uart1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart1>;
+	assigned-clocks = <&clk IMX8MP_CLK_UART1>;
+	assigned-clock-parents = <&clk IMX8MP_SYS_PLL1_80M>;
+	fsl,uart-has-rtscts;
+	status = "okay";
+};
+
+/* console */
+&uart2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart2>;
+	status = "okay";
+};
+
+/* RS-485 com3 */
+&uart3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart3>;
+	assigned-clocks = <&clk IMX8MP_CLK_UART3>;
+	assigned-clock-parents = <&clk IMX8MP_SYS_PLL1_80M>;
+	status = "okay";
+};
+
+/* for f81439 com4*/
+&uart4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart4>;
+	assigned-clocks = <&clk IMX8MP_CLK_UART4>;
+	assigned-clock-parents = <&clk IMX8MP_SYS_PLL1_80M>;
+	fsl,uart-has-rtscts;
+	status = "okay";
+};
+
+&usb3_phy0 {
+	fsl,phy-tx-vref-tune = <6>;
+	fsl,phy-tx-rise-tune = <0>;
+	fsl,phy-tx-preemp-amp-tune = <3>;
+	fsl,phy-comp-dis-tune = <7>;
+	fsl,pcs-tx-deemph-3p5db = <0x21>;
+	fsl,phy-pcs-tx-swing-full = <0x7f>;
+	status = "okay";
+};
+
+&usb3_0 {
+	status = "okay";
+};
+
+&usb_dwc3_0 {
+	dr_mode = "otg";
+	hnp-disable;
+	srp-disable;
+	adp-disable;
+	usb-role-switch;
+	status = "okay";
+
+	port {
+		usb3_drd_sw: endpoint {
+			remote-endpoint = <&otg_sw>;
+		};
+	};
+};
+
+&usb3_phy1 {
+	fsl,phy-tx-preemp-amp-tune = <2>;
+	status = "okay";
+};
+
+&usb3_1 {
+	status = "okay";
+};
+
+&usb_dwc3_1 {
+	dr_mode = "host";
+	status = "okay";
+};
+
+&usdhc2 {
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+	pinctrl-0 = <&pinctrl_usdhc2>, <&pinctrl_usdhc2_gpio>;
+	pinctrl-1 = <&pinctrl_usdhc2_100mhz>, <&pinctrl_usdhc2_gpio>;
+	pinctrl-2 = <&pinctrl_usdhc2_200mhz>, <&pinctrl_usdhc2_gpio>;
+	cd-gpios = <&gpio2 12 GPIO_ACTIVE_LOW>;
+	vmmc-supply = <&reg_usdhc2_vmmc>;
+	bus-width = <4>;
+	status = "okay";
+};
+
+/* eMMC */
+&usdhc3 {
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+	pinctrl-0 = <&pinctrl_usdhc3>;
+	pinctrl-1 = <&pinctrl_usdhc3_100mhz>;
+	pinctrl-2 = <&pinctrl_usdhc3_200mhz>;
+	bus-width = <8>;
+	non-removable;
+	status = "okay";
+};
+
+&wdog1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_wdog>;
+	fsl,ext-reset-output;
+	status = "okay";
+};
+
+&iomuxc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hog>;
+
+	pinctrl_hog: hoggrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_HDMI_DDC_SCL__HDMIMIX_EARC_SCL	0x400001c3
+			MX8MP_IOMUXC_HDMI_DDC_SDA__HDMIMIX_EARC_SDA	0x400001c3
+			MX8MP_IOMUXC_HDMI_HPD__HDMIMIX_EARC_DC_HPD	0x40000019
+			MX8MP_IOMUXC_HDMI_CEC__HDMIMIX_EARC_CEC		0x40000019
+			MX8MP_IOMUXC_SD1_CLK__GPIO2_IO00	0x16
+			MX8MP_IOMUXC_SD1_CMD__GPIO2_IO01	0x16
+			MX8MP_IOMUXC_SD1_DATA0__GPIO2_IO02	0x16
+			MX8MP_IOMUXC_SD1_DATA1__GPIO2_IO03	0x16
+			MX8MP_IOMUXC_SD1_DATA2__GPIO2_IO04	0x16
+			MX8MP_IOMUXC_SD1_DATA3__GPIO2_IO05	0x16
+			MX8MP_IOMUXC_SD1_DATA4__GPIO2_IO06	0x16
+			MX8MP_IOMUXC_SD1_DATA5__GPIO2_IO07	0x16
+
+			MX8MP_IOMUXC_SAI3_RXFS__GPIO4_IO28	0x16 /* FAN_FAULT# */
+			MX8MP_IOMUXC_SAI3_RXC__GPIO4_IO29	0x16 /* OVT# */
+		>;
+	};
+
+	pinctrl_sai3: sai3grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SAI3_TXFS__AUDIOMIX_SAI3_TX_SYNC   0xd6
+			MX8MP_IOMUXC_SAI3_TXC__AUDIOMIX_SAI3_TX_BCLK    0xd6
+			MX8MP_IOMUXC_SAI3_RXD__AUDIOMIX_SAI3_RX_DATA00  0xd6
+			MX8MP_IOMUXC_SAI3_TXD__AUDIOMIX_SAI3_TX_DATA00  0xd6
+			MX8MP_IOMUXC_SAI3_MCLK__AUDIOMIX_SAI3_MCLK      0xd6
+		>;
+	};
+
+	pinctrl_backlight_en: backlight_en {
+		fsl,pins = <
+			MX8MP_IOMUXC_GPIO1_IO01__GPIO1_IO01 0x16 /* LVDS_BL_EN */
+		>;
+	};
+
+	pinctrl_backlight_pwm2: backlight_pwm2 {
+		fsl,pins = <
+			MX8MP_IOMUXC_GPIO1_IO09__PWM2_OUT	0x116
+		>;
+	};
+
+	pinctrl_panel_pwr_en: panel_pwr_en {
+		fsl,pins = <
+			MX8MP_IOMUXC_GPIO1_IO00__GPIO1_IO00	0x16 /* panel power en */
+		>;
+	};
+
+	pinctrl_touch_irq: touch_irq {
+		fsl,pins = <
+			MX8MP_IOMUXC_SD1_RESET_B__GPIO2_IO10 0x16 /* touch irq */
+		>;
+	};
+
+	pinctrl_touch_rst: touch_rst {
+		fsl,pins = <
+			MX8MP_IOMUXC_SD1_STROBE__GPIO2_IO11 0x16 /* touch rst */
+		>;
+	};
+
+	pinctrl_sd_en: sd_en {
+		fsl,pins = <
+			MX8MP_IOMUXC_SD1_DATA6__GPIO2_IO08 0x16 /* uSD Enable */
+		>;
+	};
+
+	pinctrl_usb_hub_en: usb_hub_en {
+		fsl,pins = <
+			MX8MP_IOMUXC_SAI5_MCLK__GPIO3_IO25 0x16 /* USB Hub Enable */
+		>;
+	};
+
+	pinctrl_usb2_typea_en: usb2_typea_en {
+		fsl,pins = <
+			MX8MP_IOMUXC_SAI5_RXD2__GPIO3_IO23 0x16 /* USB 2.0-TypeA Enable */
+		>;
+	};
+
+	pinctrl_usb2_hdr_en: usb2_hdr_en {
+		fsl,pins = <
+			MX8MP_IOMUXC_SAI5_RXD3__GPIO3_IO24 0x16 /* USB 2.0-HDR Enable */
+		>;
+	};
+
+	pinctrl_usb2_otg_en: usb2_otg_en {
+		fsl,pins = <
+			MX8MP_IOMUXC_SAI5_RXD0__GPIO3_IO21 0x16 /* USB2_OTG Enable */
+		>;
+	};
+
+	pinctrl_usb3_typea_en: usb3_typea_en {
+		fsl,pins = <
+			MX8MP_IOMUXC_SAI5_RXD1__GPIO3_IO22 0x16 /* USB 3.0-TypeA Enable */
+		>;
+	};
+
+	pinctrl_dac5571_bl_en: dac5571_bl_en {
+		fsl,pins = <
+			MX8MP_IOMUXC_GPIO1_IO10__GPIO1_IO10	0x16 /* DAC5571_BL Enable */
+		>;
+	};
+
+	pinctrl_lvds_pwr_en: lvds_pwr_en {
+		fsl,pins = <
+			MX8MP_IOMUXC_SAI5_RXD2__GPIO3_IO23	0x16 /* LVDS Power Enable */
+		>;
+	};
+
+	pinctrl_buzzer: buzzer {
+		fsl,pins = <
+			MX8MP_IOMUXC_SPDIF_EXT_CLK__PWM1_OUT	0x116
+		>;
+	};
+
+	pinctrl_pwm3: pwm3grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_GPIO1_IO14__PWM3_OUT	0x116
+		>;
+	};
+
+	pinctrl_ecspi1: ecspi1grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_ECSPI1_SCLK__ECSPI1_SCLK		0x82
+			MX8MP_IOMUXC_ECSPI1_MOSI__ECSPI1_MOSI		0x82
+			MX8MP_IOMUXC_ECSPI1_MISO__ECSPI1_MISO		0x82
+		>;
+	};
+
+	pinctrl_ecspi1_cs: ecspi1cs {
+		fsl,pins = <
+			MX8MP_IOMUXC_ECSPI1_SS0__ECSPI1_SS0		0x40000
+		>;
+	};
+
+	pinctrl_eqos: eqosgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_ENET_MDC__ENET_QOS_MDC	0x3
+			MX8MP_IOMUXC_ENET_MDIO__ENET_QOS_MDIO	0x3
+			MX8MP_IOMUXC_ENET_RD0__ENET_QOS_RGMII_RD0	0x91
+			MX8MP_IOMUXC_ENET_RD1__ENET_QOS_RGMII_RD1	0x91
+			MX8MP_IOMUXC_ENET_RD2__ENET_QOS_RGMII_RD2	0x91
+			MX8MP_IOMUXC_ENET_RD3__ENET_QOS_RGMII_RD3	0x91
+			MX8MP_IOMUXC_ENET_RXC__CCM_ENET_QOS_CLOCK_GENERATE_RX_CLK	0x91
+			MX8MP_IOMUXC_ENET_RX_CTL__ENET_QOS_RGMII_RX_CTL	0x91
+			MX8MP_IOMUXC_ENET_TD0__ENET_QOS_RGMII_TD0		0x1f
+			MX8MP_IOMUXC_ENET_TD1__ENET_QOS_RGMII_TD1		0x1f
+			MX8MP_IOMUXC_ENET_TD2__ENET_QOS_RGMII_TD2		0x1f
+			MX8MP_IOMUXC_ENET_TD3__ENET_QOS_RGMII_TD3		0x1f
+			MX8MP_IOMUXC_ENET_TX_CTL__ENET_QOS_RGMII_TX_CTL	0x1f
+			MX8MP_IOMUXC_ENET_TXC__CCM_ENET_QOS_CLOCK_GENERATE_TX_CLK	0x1f
+		>;
+	};
+
+	pinctrl_eqos_rst_en: eqos_rst_en {
+		fsl,pins = <
+			MX8MP_IOMUXC_SAI1_RXFS__GPIO4_IO00		0x19
+		>;
+	};
+
+	pinctrl_fec: fecgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SAI1_RXD2__ENET1_MDC		0x3
+			MX8MP_IOMUXC_SAI1_RXD3__ENET1_MDIO		0x3
+			MX8MP_IOMUXC_SAI1_RXD4__ENET1_RGMII_RD0		0x91
+			MX8MP_IOMUXC_SAI1_RXD5__ENET1_RGMII_RD1		0x91
+			MX8MP_IOMUXC_SAI1_RXD6__ENET1_RGMII_RD2		0x91
+			MX8MP_IOMUXC_SAI1_RXD7__ENET1_RGMII_RD3		0x91
+			MX8MP_IOMUXC_SAI1_TXC__ENET1_RGMII_RXC		0x91
+			MX8MP_IOMUXC_SAI1_TXFS__ENET1_RGMII_RX_CTL	0x91
+			MX8MP_IOMUXC_SAI1_TXD0__ENET1_RGMII_TD0		0x1f
+			MX8MP_IOMUXC_SAI1_TXD1__ENET1_RGMII_TD1		0x1f
+			MX8MP_IOMUXC_SAI1_TXD2__ENET1_RGMII_TD2		0x1f
+			MX8MP_IOMUXC_SAI1_TXD3__ENET1_RGMII_TD3		0x1f
+			MX8MP_IOMUXC_SAI1_TXD4__ENET1_RGMII_TX_CTL	0x1f
+			MX8MP_IOMUXC_SAI1_TXD5__ENET1_RGMII_TXC		0x1f
+		>;
+	};
+
+	pinctrl_fec_rst_en: fec_rst_en {
+		fsl,pins = <
+			MX8MP_IOMUXC_SAI1_RXD0__GPIO4_IO02		0x19
+		>;
+	};
+
+	pinctrl_flexcan1: flexcan1grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SPDIF_RX__CAN1_RX          0x154
+			MX8MP_IOMUXC_SPDIF_TX__CAN1_TX          0x154
+		>;
+	};
+
+	pinctrl_dbg_led: dbgledgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_NAND_DATA00__GPIO3_IO06	0x19
+		>;
+	};
+
+	pinctrl_sys_led: sysledgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_NAND_READY_B__GPIO3_IO16	0x19
+		>;
+	};
+
+	pinctrl_i2c1: i2c1grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_I2C1_SCL__I2C1_SCL		0x400001c3
+			MX8MP_IOMUXC_I2C1_SDA__I2C1_SDA		0x400001c3
+		>;
+	};
+
+	pinctrl_i2c2: i2c2grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_I2C2_SCL__I2C2_SCL			0x400001c3
+			MX8MP_IOMUXC_I2C2_SDA__I2C2_SDA			0x400001c3
+		>;
+	};
+
+	pinctrl_i2c3: i2c3grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_I2C3_SCL__I2C3_SCL			0x400001c3
+			MX8MP_IOMUXC_I2C3_SDA__I2C3_SDA			0x400001c3
+		>;
+	};
+
+	pinctrl_i2c4: i2c4grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_I2C4_SCL__I2C4_SCL			0x400001c3
+			MX8MP_IOMUXC_I2C4_SDA__I2C4_SDA			0x400001c3
+		>;
+	};
+
+	pinctrl_pcie: pciegrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_UART4_RXD__HSIOMIX_PCIE_CLKREQ_B	0x61	/* open drain, pull up */
+			MX8MP_IOMUXC_GPIO1_IO15__GPIO1_IO15		0x41 /* PCIe_nRST */
+			MX8MP_IOMUXC_GPIO1_IO13__GPIO1_IO13		0x41 /* PCIe_nDIS */
+		>;
+	};
+
+	pinctrl_pmic: pmicirq {
+		fsl,pins = <
+			MX8MP_IOMUXC_GPIO1_IO03__GPIO1_IO03	0x41
+		>;
+	};
+
+	pinctrl_com_pwr_en: com_pwr_en {
+		fsl,pins = <
+				MX8MP_IOMUXC_SD1_DATA7__GPIO2_IO09      0x16 /* COM_PWR_EN */
+		>;
+	};
+
+	pinctrl_uart1: uart1grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SAI2_RXC__UART1_DCE_RX     0x140
+			MX8MP_IOMUXC_SAI2_RXFS__UART1_DCE_TX    0x140
+			MX8MP_IOMUXC_SAI2_TXFS__UART1_DCE_CTS   0x140
+			MX8MP_IOMUXC_SAI2_RXD0__UART1_DCE_RTS   0x140
+		>;
+	};
+
+	pinctrl_uart2: uart2grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_UART2_RXD__UART2_DCE_RX	0x49
+			MX8MP_IOMUXC_UART2_TXD__UART2_DCE_TX	0x49
+		>;
+	};
+
+	pinctrl_uart3: uart3grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_UART3_RXD__UART3_DCE_RX            0x140
+			MX8MP_IOMUXC_UART3_TXD__UART3_DCE_TX            0x140
+		>;
+	};
+
+	pinctrl_uart4: uart4grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_ECSPI2_SS0__UART4_DCE_RTS		0x140
+			MX8MP_IOMUXC_ECSPI2_MOSI__UART4_DCE_TX		0x140
+			MX8MP_IOMUXC_ECSPI2_MISO__UART4_DCE_CTS		0x140
+			MX8MP_IOMUXC_ECSPI2_SCLK__UART4_DCE_RX		0x140
+		>;
+	};
+
+	pinctrl_f81439: f81439grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SAI2_TXC__GPIO4_IO25			0x140
+			MX8MP_IOMUXC_SAI2_TXD0__GPIO4_IO26			0x140
+			MX8MP_IOMUXC_SAI2_MCLK__GPIO4_IO27			0x140
+		>;
+	};
+
+	pinctrl_usdhc2_gpio: usdhc2grp-gpio {
+		fsl,pins = <
+			MX8MP_IOMUXC_SD2_CD_B__GPIO2_IO12 	0x1c4
+			MX8MP_IOMUXC_SD2_RESET_B__GPIO2_IO19	0x41
+		>;
+	};
+
+	pinctrl_usdhc2: usdhc2grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SD2_CLK__USDHC2_CLK	0x190
+			MX8MP_IOMUXC_SD2_CMD__USDHC2_CMD	0x1d0
+			MX8MP_IOMUXC_SD2_DATA0__USDHC2_DATA0	0x1d0
+			MX8MP_IOMUXC_SD2_DATA1__USDHC2_DATA1	0x1d0
+			MX8MP_IOMUXC_SD2_DATA2__USDHC2_DATA2	0x1d0
+			MX8MP_IOMUXC_SD2_DATA3__USDHC2_DATA3	0x1d0
+			MX8MP_IOMUXC_GPIO1_IO04__USDHC2_VSELECT	0xc1
+		>;
+	};
+
+	pinctrl_usdhc2_100mhz: usdhc2grp-100mhz {
+		fsl,pins = <
+			MX8MP_IOMUXC_SD2_CLK__USDHC2_CLK	0x194
+			MX8MP_IOMUXC_SD2_CMD__USDHC2_CMD	0x1d4
+			MX8MP_IOMUXC_SD2_DATA0__USDHC2_DATA0	0x1d4
+			MX8MP_IOMUXC_SD2_DATA1__USDHC2_DATA1	0x1d4
+			MX8MP_IOMUXC_SD2_DATA2__USDHC2_DATA2	0x1d4
+			MX8MP_IOMUXC_SD2_DATA3__USDHC2_DATA3	0x1d4
+			MX8MP_IOMUXC_GPIO1_IO04__USDHC2_VSELECT 0xc1
+		>;
+	};
+
+	pinctrl_usdhc2_200mhz: usdhc2grp-200mhz {
+		fsl,pins = <
+			MX8MP_IOMUXC_SD2_CLK__USDHC2_CLK	0x196
+			MX8MP_IOMUXC_SD2_CMD__USDHC2_CMD	0x1d6
+			MX8MP_IOMUXC_SD2_DATA0__USDHC2_DATA0	0x1d6
+			MX8MP_IOMUXC_SD2_DATA1__USDHC2_DATA1	0x1d6
+			MX8MP_IOMUXC_SD2_DATA2__USDHC2_DATA2	0x1d6
+			MX8MP_IOMUXC_SD2_DATA3__USDHC2_DATA3	0x1d6
+			MX8MP_IOMUXC_GPIO1_IO04__USDHC2_VSELECT 0xc1
+		>;
+	};
+
+	pinctrl_usdhc3: usdhc3grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_NAND_WE_B__USDHC3_CLK	0x190
+			MX8MP_IOMUXC_NAND_WP_B__USDHC3_CMD	0x1d0
+			MX8MP_IOMUXC_NAND_DATA04__USDHC3_DATA0	0x1d0
+			MX8MP_IOMUXC_NAND_DATA05__USDHC3_DATA1	0x1d0
+			MX8MP_IOMUXC_NAND_DATA06__USDHC3_DATA2	0x1d0
+			MX8MP_IOMUXC_NAND_DATA07__USDHC3_DATA3	0x1d0
+			MX8MP_IOMUXC_NAND_RE_B__USDHC3_DATA4	0x1d0
+			MX8MP_IOMUXC_NAND_CE2_B__USDHC3_DATA5	0x1d0
+			MX8MP_IOMUXC_NAND_CE3_B__USDHC3_DATA6	0x1d0
+			MX8MP_IOMUXC_NAND_CLE__USDHC3_DATA7	0x1d0
+			MX8MP_IOMUXC_NAND_CE1_B__USDHC3_STROBE	0x190
+		>;
+	};
+
+	pinctrl_usdhc3_100mhz: usdhc3grp-100mhz {
+		fsl,pins = <
+			MX8MP_IOMUXC_NAND_WE_B__USDHC3_CLK	0x194
+			MX8MP_IOMUXC_NAND_WP_B__USDHC3_CMD	0x1d4
+			MX8MP_IOMUXC_NAND_DATA04__USDHC3_DATA0	0x1d4
+			MX8MP_IOMUXC_NAND_DATA05__USDHC3_DATA1	0x1d4
+			MX8MP_IOMUXC_NAND_DATA06__USDHC3_DATA2	0x1d4
+			MX8MP_IOMUXC_NAND_DATA07__USDHC3_DATA3	0x1d4
+			MX8MP_IOMUXC_NAND_RE_B__USDHC3_DATA4	0x1d4
+			MX8MP_IOMUXC_NAND_CE2_B__USDHC3_DATA5	0x1d4
+			MX8MP_IOMUXC_NAND_CE3_B__USDHC3_DATA6	0x1d4
+			MX8MP_IOMUXC_NAND_CLE__USDHC3_DATA7	0x1d4
+			MX8MP_IOMUXC_NAND_CE1_B__USDHC3_STROBE	0x194
+		>;
+	};
+
+	pinctrl_usdhc3_200mhz: usdhc3grp-200mhz {
+		fsl,pins = <
+			MX8MP_IOMUXC_NAND_WE_B__USDHC3_CLK	0x196
+			MX8MP_IOMUXC_NAND_WP_B__USDHC3_CMD	0x1d6
+			MX8MP_IOMUXC_NAND_DATA04__USDHC3_DATA0	0x1d6
+			MX8MP_IOMUXC_NAND_DATA05__USDHC3_DATA1	0x1d6
+			MX8MP_IOMUXC_NAND_DATA06__USDHC3_DATA2	0x1d6
+			MX8MP_IOMUXC_NAND_DATA07__USDHC3_DATA3	0x1d6
+			MX8MP_IOMUXC_NAND_RE_B__USDHC3_DATA4	0x1d6
+			MX8MP_IOMUXC_NAND_CE2_B__USDHC3_DATA5	0x1d6
+			MX8MP_IOMUXC_NAND_CE3_B__USDHC3_DATA6	0x1d6
+			MX8MP_IOMUXC_NAND_CLE__USDHC3_DATA7	0x1d6
+			MX8MP_IOMUXC_NAND_CE1_B__USDHC3_STROBE	0x196
+		>;
+	};
+
+	pinctrl_wdog: wdoggrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_GPIO1_IO02__WDOG1_WDOG_B	0xc6
+		>;
+	};
+
+	pinctrl_keyb_pwr_en: keyb_pwr_en {
+		fsl,pins = <
+			MX8MP_IOMUXC_GPIO1_IO11__GPIO1_IO11	0x16 /* KeyB_PWR_EN */
+		>;
+	};
+
+	pinctrl_keyb_rst_en: keyb_rst_en {
+		fsl,pins = <
+			MX8MP_IOMUXC_GPIO1_IO05__GPIO1_IO05	0x16 /* KeyB_RST_EN */
+		>;
+	};
+
+	pinctrl_otg_sw: otg_sw {
+		fsl,pins = <
+			MX8MP_IOMUXC_GPIO1_IO10__GPIO1_IO10		0x1C4
+		>;
+	};
+};
+
+&vpu_g1 {
+	status = "okay";
+};
+
+&vpu_g2 {
+	status = "okay";
+};
+
+&vpu_vc8000e {
+	status = "okay";
+};
+
+&gpu_3d {
+	status = "okay";
+};
+
+&gpu_2d {
+	status = "okay";
+};
+
+&ml_vipsi {
+	status = "okay";
+};
+
+&mix_gpu_ml {
+	status = "okay";
+};
+
+&mipi_csi_0 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "disabled";
+};
+
+&mipi_csi_1 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "disabled";
+};
+
+&cameradev {
+	status = "okay";
+};
+
+&isp_0 {
+	status = "okay";
+};
+
+&isp_1 {
+	status = "okay";
+};
+
+&isi_0 {
+	status = "okay";
+
+	cap_device {
+		status = "okay";
+	};
+
+	m2m_device {
+		status = "okay";
+	};
+};
+
+&isi_1 {
+	status = "okay";
+
+	cap_device {
+		status = "okay";
+	};
+};
+
+&irqsteer_hdmi {
+	status = "okay";
+};
+
+&hdmimix_clk {
+	status = "okay";
+};
+
+&hdmimix_reset {
+	status = "okay";
+};
+
+&hdmi_pavi {
+	status = "okay";
+};
+
+&hdmi {
+	status = "okay";
+};
+
+&hdmiphy {
+	status = "okay";
+};
diff --git a/arch/arm64/configs/imx_m8mp553_defconfig b/arch/arm64/configs/imx_m8mp553_defconfig
new file mode 100644
index 000000000..910dfa4e7
--- /dev/null
+++ b/arch/arm64/configs/imx_m8mp553_defconfig
@@ -0,0 +1,870 @@
+CONFIG_SYSVIPC=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_AUDIT=y
+CONFIG_NO_HZ_IDLE=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_PREEMPT=y
+CONFIG_IRQ_TIME_ACCOUNTING=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_TASKSTATS=y
+CONFIG_TASK_DELAY_ACCT=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_NUMA_BALANCING=y
+CONFIG_MEMCG=y
+CONFIG_MEMCG_SWAP=y
+CONFIG_BLK_CGROUP=y
+CONFIG_CGROUP_PIDS=y
+CONFIG_CGROUP_HUGETLB=y
+CONFIG_CPUSETS=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_CGROUP_PERF=y
+CONFIG_USER_NS=y
+CONFIG_SCHED_AUTOGROUP=y
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_KALLSYMS_ALL=y
+# CONFIG_COMPAT_BRK is not set
+CONFIG_PROFILING=y
+CONFIG_ARCH_LAYERSCAPE=y
+CONFIG_ARCH_MXC=y
+CONFIG_ARCH_S32=y
+CONFIG_SOC_S32V234=y
+CONFIG_ARM64_VA_BITS_48=y
+CONFIG_SCHED_MC=y
+CONFIG_NUMA=y
+CONFIG_SECCOMP=y
+CONFIG_KEXEC=y
+CONFIG_CRASH_DUMP=y
+CONFIG_XEN=y
+CONFIG_FORCE_MAX_ZONEORDER=14
+CONFIG_COMPAT=y
+CONFIG_RANDOMIZE_BASE=y
+CONFIG_PM_DEBUG=y
+CONFIG_PM_TEST_SUSPEND=y
+CONFIG_WQ_POWER_EFFICIENT_DEFAULT=y
+CONFIG_ARM_CPUIDLE=y
+CONFIG_ARM_PSCI_CPUIDLE=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPU_FREQ_GOV_SCHEDUTIL=y
+CONFIG_CPUFREQ_DT=y
+CONFIG_ACPI_CPPC_CPUFREQ=m
+CONFIG_ARM_SCPI_CPUFREQ=y
+CONFIG_ARM_IMX_CPUFREQ_DT=y
+CONFIG_QORIQ_CPUFREQ=y
+CONFIG_ARM_SCPI_PROTOCOL=y
+CONFIG_EFI_CAPSULE_LOADER=y
+CONFIG_IMX_DSP=y
+CONFIG_IMX_SCU=y
+CONFIG_IMX_SCU_PD=y
+CONFIG_IMX_SECO_MU=y
+CONFIG_ACPI=y
+CONFIG_ACPI_APEI=y
+CONFIG_ACPI_APEI_GHES=y
+CONFIG_ACPI_APEI_PCIEAER=y
+CONFIG_ACPI_APEI_MEMORY_FAILURE=y
+CONFIG_ACPI_APEI_EINJ=y
+CONFIG_VIRTUALIZATION=y
+CONFIG_KVM=y
+CONFIG_ARM64_CRYPTO=y
+CONFIG_CRYPTO_SHA1_ARM64_CE=y
+CONFIG_CRYPTO_SHA2_ARM64_CE=y
+CONFIG_CRYPTO_SHA512_ARM64_CE=m
+CONFIG_CRYPTO_SHA3_ARM64=m
+CONFIG_CRYPTO_SM3_ARM64_CE=m
+CONFIG_CRYPTO_GHASH_ARM64_CE=y
+CONFIG_CRYPTO_CRCT10DIF_ARM64_CE=m
+CONFIG_CRYPTO_AES_ARM64_CE_CCM=y
+CONFIG_CRYPTO_AES_ARM64_CE_BLK=y
+CONFIG_CRYPTO_CHACHA20_NEON=m
+CONFIG_CRYPTO_AES_ARM64_BS=m
+CONFIG_JUMP_LABEL=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_KSM=y
+CONFIG_MEMORY_FAILURE=y
+CONFIG_TRANSPARENT_HUGEPAGE=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IPV6_SIT=m
+CONFIG_NETFILTER=y
+CONFIG_NF_CONNTRACK=m
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_NETFILTER_XT_TARGET_CHECKSUM=m
+CONFIG_NETFILTER_XT_TARGET_LOG=m
+CONFIG_NETFILTER_XT_MATCH_ADDRTYPE=m
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=m
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_REJECT=m
+CONFIG_IP_NF_NAT=m
+CONFIG_IP_NF_TARGET_MASQUERADE=m
+CONFIG_IP_NF_MANGLE=m
+CONFIG_IP6_NF_IPTABLES=m
+CONFIG_IP6_NF_FILTER=m
+CONFIG_IP6_NF_TARGET_REJECT=m
+CONFIG_IP6_NF_MANGLE=m
+CONFIG_IP6_NF_NAT=m
+CONFIG_IP6_NF_TARGET_MASQUERADE=m
+CONFIG_BRIDGE=m
+CONFIG_BRIDGE_VLAN_FILTERING=y
+CONFIG_VLAN_8021Q_GVRP=y
+CONFIG_VLAN_8021Q_MVRP=y
+CONFIG_LLC2=y
+CONFIG_NET_SCHED=y
+CONFIG_NET_SCH_MULTIQ=y
+CONFIG_NET_SCH_CBS=y
+CONFIG_NET_SCH_TAPRIO=y
+CONFIG_NET_SCH_MQPRIO=y
+CONFIG_NET_CLS_BASIC=y
+CONFIG_NET_CLS_TCINDEX=y
+CONFIG_TSN=y
+CONFIG_NET_SWITCHDEV=y
+CONFIG_BPF_JIT=y
+CONFIG_NET_PKTGEN=y
+CONFIG_CAN=m
+CONFIG_CAN_FLEXCAN=m
+CONFIG_BT=y
+CONFIG_BT_RFCOMM=y
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=y
+CONFIG_BT_BNEP_MC_FILTER=y
+CONFIG_BT_BNEP_PROTO_FILTER=y
+CONFIG_BT_HIDP=y
+# CONFIG_BT_HS is not set
+# CONFIG_BT_LE is not set
+CONFIG_BT_LEDS=y
+# CONFIG_BT_DEBUGFS is not set
+CONFIG_BT_HCIBTUSB=y
+# CONFIG_BT_HCIBTUSB_BCM is not set
+# CONFIG_BT_HCIBTUSB_RTL is not set
+CONFIG_BT_HCIVHCI=y
+CONFIG_CFG80211=y
+CONFIG_NL80211_TESTMODE=y
+CONFIG_CFG80211_WEXT=y
+CONFIG_MAC80211=y
+CONFIG_MAC80211_LEDS=y
+CONFIG_NET_9P=y
+CONFIG_NET_9P_VIRTIO=y
+CONFIG_PCI=y
+CONFIG_PCIEPORTBUS=y
+CONFIG_PCI_IOV=y
+CONFIG_HOTPLUG_PCI=y
+CONFIG_HOTPLUG_PCI_ACPI=y
+CONFIG_PCI_HOST_GENERIC=y
+CONFIG_PCI_XGENE=y
+CONFIG_PCIE_ALTERA=y
+CONFIG_PCIE_ALTERA_MSI=y
+CONFIG_PCI_HOST_THUNDER_PEM=y
+CONFIG_PCI_HOST_THUNDER_ECAM=y
+CONFIG_PCI_IMX6=y
+CONFIG_PCI_LAYERSCAPE=y
+CONFIG_PCI_HISI=y
+CONFIG_PCIE_KIRIN=y
+CONFIG_PCIE_LAYERSCAPE_GEN4=y
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_FW_LOADER_USER_HELPER=y
+CONFIG_FW_LOADER_USER_HELPER_FALLBACK=y
+CONFIG_BRCMSTB_GISB_ARB=y
+CONFIG_SIMPLE_PM_BUS=y
+CONFIG_VEXPRESS_CONFIG=y
+CONFIG_FSL_MC_BUS=y
+CONFIG_FSL_MC_UAPI_SUPPORT=y
+CONFIG_MTD=y
+CONFIG_MTD_CMDLINE_PARTS=y
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_CFI=y
+CONFIG_MTD_CFI_ADV_OPTIONS=y
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_STAA=y
+CONFIG_MTD_PHYSMAP=y
+CONFIG_MTD_PHYSMAP_OF=y
+CONFIG_MTD_DATAFLASH=y
+CONFIG_MTD_SST25L=y
+CONFIG_MTD_RAW_NAND=y
+CONFIG_MTD_NAND_DENALI_DT=y
+CONFIG_MTD_NAND_GPMI_NAND=y
+CONFIG_MTD_NAND_FSL_IFC=y
+CONFIG_MTD_SPI_NOR=y
+# CONFIG_MTD_SPI_NOR_USE_4K_SECTORS is not set
+CONFIG_MTD_UBI=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_NBD=m
+CONFIG_XEN_BLKDEV_BACKEND=m
+CONFIG_VIRTIO_BLK=y
+CONFIG_BLK_DEV_NVME=y
+CONFIG_SENSORS_FXOS8700=y
+CONFIG_SENSORS_FXAS2100X=y
+CONFIG_SRAM=y
+CONFIG_FINTEK_F81439=m
+CONFIG_EEPROM_AT24=y
+CONFIG_EEPROM_AT25=m
+# CONFIG_SCSI_PROC_FS is not set
+CONFIG_BLK_DEV_SD=y
+CONFIG_SCSI_SAS_ATA=y
+CONFIG_SCSI_HISI_SAS=y
+CONFIG_SCSI_HISI_SAS_PCI=y
+CONFIG_SCSI_MPT3SAS=m
+CONFIG_SCSI_UFSHCD=y
+CONFIG_SCSI_UFSHCD_PLATFORM=y
+CONFIG_ATA=y
+CONFIG_SATA_AHCI=y
+CONFIG_SATA_AHCI_PLATFORM=y
+CONFIG_AHCI_IMX=y
+CONFIG_AHCI_CEVA=y
+CONFIG_AHCI_XGENE=y
+CONFIG_AHCI_QORIQ=y
+CONFIG_SATA_SIL24=y
+CONFIG_PATA_PLATFORM=y
+CONFIG_PATA_OF_PLATFORM=y
+CONFIG_MD=y
+CONFIG_BLK_DEV_MD=m
+CONFIG_BLK_DEV_DM=m
+CONFIG_DM_MIRROR=m
+CONFIG_DM_ZERO=m
+CONFIG_NETDEVICES=y
+CONFIG_MACVLAN=m
+CONFIG_MACVTAP=m
+CONFIG_TUN=y
+CONFIG_VETH=m
+CONFIG_VIRTIO_NET=y
+CONFIG_AMD_XGBE=y
+CONFIG_ATL1C=m
+CONFIG_BNX2X=m
+CONFIG_MACB=y
+CONFIG_THUNDER_NIC_PF=y
+CONFIG_FEC=y
+CONFIG_FSL_SDK_DPAA_ETH=y
+CONFIG_FSL_DPAA2_ETH=y
+CONFIG_FSL_ENETC=y
+CONFIG_FSL_ENETC_VF=y
+CONFIG_HIX5HD2_GMAC=y
+CONFIG_HNS_DSAF=y
+CONFIG_HNS_ENET=y
+CONFIG_HNS3=y
+CONFIG_HNS3_HCLGE=y
+CONFIG_HNS3_ENET=y
+CONFIG_E1000=y
+CONFIG_E1000E=y
+CONFIG_IGB=y
+CONFIG_IGBVF=y
+CONFIG_MVMDIO=y
+CONFIG_SKY2=y
+CONFIG_MLX4_EN=m
+CONFIG_MLX5_CORE=m
+CONFIG_MLX5_CORE_EN=y
+CONFIG_MSCC_OCELOT_SWITCH=y
+CONFIG_QCOM_EMAC=m
+CONFIG_SMC91X=y
+CONFIG_SMSC911X=y
+CONFIG_STMMAC_ETH=y
+CONFIG_MDIO_BITBANG=y
+CONFIG_MDIO_BUS_MUX_MULTIPLEXER=y
+CONFIG_AQUANTIA_PHY=y
+CONFIG_AT803X_PHY=y
+CONFIG_INPHI_PHY=y
+CONFIG_MARVELL_PHY=m
+CONFIG_MARVELL_10G_PHY=m
+CONFIG_MICREL_PHY=y
+CONFIG_MICROSEMI_PHY=y
+CONFIG_NXP_TJA11XX_PHY=y
+CONFIG_REALTEK_PHY=y
+CONFIG_ROCKCHIP_PHY=y
+CONFIG_VITESSE_PHY=y
+CONFIG_USB_PEGASUS=m
+CONFIG_USB_RTL8150=m
+CONFIG_USB_RTL8152=m
+CONFIG_USB_LAN78XX=m
+CONFIG_USB_USBNET=m
+CONFIG_USB_NET_DM9601=m
+CONFIG_USB_NET_SR9800=m
+CONFIG_USB_NET_SMSC75XX=m
+CONFIG_USB_NET_SMSC95XX=m
+CONFIG_USB_NET_PLUSB=m
+CONFIG_USB_NET_MCS7830=m
+CONFIG_USB_NET_SIMCOM_LTE_5G=m
+CONFIG_BRCMFMAC=m
+CONFIG_BRCMFMAC_PCIE=y
+CONFIG_HOSTAP=y
+CONFIG_MXMWIFIEX=m
+CONFIG_WL18XX=m
+CONFIG_WLCORE_SDIO=m
+CONFIG_IVSHMEM_NET=y
+CONFIG_INPUT_EVDEV=y
+CONFIG_KEYBOARD_ADC=m
+CONFIG_KEYBOARD_GPIO=y
+CONFIG_KEYBOARD_SNVS_PWRKEY=y
+CONFIG_KEYBOARD_IMX_SC_PWRKEY=y
+CONFIG_KEYBOARD_CROS_EC=y
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_ATMEL_MXT=m
+CONFIG_TOUCHSCREEN_ILI210X=m
+CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_I2C=m
+CONFIG_INPUT_MISC=y
+CONFIG_INPUT_MPL3115=y
+CONFIG_INPUT_ISL29023=y
+# CONFIG_SERIO_SERPORT is not set
+CONFIG_SERIO_AMBAKMI=y
+CONFIG_LEGACY_PTY_COUNT=16
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_EXTENDED=y
+CONFIG_SERIAL_8250_SHARE_IRQ=y
+CONFIG_SERIAL_8250_DW=y
+CONFIG_SERIAL_OF_PLATFORM=y
+CONFIG_SERIAL_AMBA_PL011=y
+CONFIG_SERIAL_AMBA_PL011_CONSOLE=y
+CONFIG_SERIAL_IMX=y
+CONFIG_SERIAL_IMX_CONSOLE=y
+CONFIG_SERIAL_XILINX_PS_UART=y
+CONFIG_SERIAL_XILINX_PS_UART_CONSOLE=y
+CONFIG_SERIAL_FSL_LPUART=y
+CONFIG_SERIAL_FSL_LPUART_CONSOLE=y
+CONFIG_SERIAL_FSL_LINFLEXUART=y
+CONFIG_SERIAL_FSL_LINFLEXUART_CONSOLE=y
+CONFIG_SERIAL_DEV_BUS=y
+CONFIG_VIRTIO_CONSOLE=y
+CONFIG_IPMI_HANDLER=m
+CONFIG_IPMI_DEVICE_INTERFACE=m
+CONFIG_IPMI_SI=m
+CONFIG_TCG_TPM=y
+CONFIG_TCG_TIS_I2C_INFINEON=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_MUX=y
+CONFIG_I2C_MUX_PCA954x=y
+CONFIG_I2C_DESIGNWARE_PLATFORM=y
+CONFIG_I2C_GPIO=m
+CONFIG_I2C_IMX=y
+CONFIG_I2C_IMX_LPI2C=y
+CONFIG_I2C_RK3X=y
+CONFIG_I2C_RPBUS=y
+CONFIG_I2C_CROS_EC_TUNNEL=y
+CONFIG_XEN_I2C_BACKEND=y
+CONFIG_I2C_SLAVE=y
+CONFIG_SPI=y
+CONFIG_SPI_FSL_LPSPI=y
+CONFIG_SPI_FSL_QUADSPI=y
+CONFIG_SPI_NXP_FLEXSPI=y
+CONFIG_SPI_IMX=y
+CONFIG_SPI_FSL_DSPI=y
+CONFIG_SPI_PL022=y
+CONFIG_SPI_ROCKCHIP=y
+CONFIG_SPI_SPIDEV=y
+CONFIG_SPI_SLAVE=y
+CONFIG_SPI_SLAVE_TIME=y
+CONFIG_SPI_SLAVE_SYSTEM_CONTROL=y
+CONFIG_SPMI=y
+CONFIG_PINCTRL_SINGLE=y
+CONFIG_PINCTRL_MAX77620=y
+CONFIG_PINCTRL_IMX8MM=y
+CONFIG_PINCTRL_IMX8MN=y
+CONFIG_PINCTRL_IMX8MP=y
+CONFIG_PINCTRL_IMX8MQ=y
+CONFIG_PINCTRL_IMX8QM=y
+CONFIG_PINCTRL_IMX8QXP=y
+CONFIG_PINCTRL_IMX8DXL=y
+CONFIG_PINCTRL_S32V234=y
+CONFIG_GPIOLIB=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_DWAPB=y
+CONFIG_GPIO_MB86S7X=y
+CONFIG_GPIO_MPC8XXX=y
+CONFIG_GPIO_PL061=y
+CONFIG_GPIO_XGENE=y
+CONFIG_GPIO_MAX732X=y
+CONFIG_GPIO_PCA953X=y
+CONFIG_GPIO_PCA953X_IRQ=y
+CONFIG_GPIO_MAX77620=y
+CONFIG_POWER_AVS=y
+CONFIG_POWER_RESET_BRCMSTB=y
+CONFIG_POWER_RESET_VEXPRESS=y
+CONFIG_POWER_RESET_XGENE=y
+CONFIG_POWER_RESET_SYSCON=y
+CONFIG_SYSCON_REBOOT_MODE=y
+CONFIG_BATTERY_SBS=m
+CONFIG_BATTERY_BQ27XXX=y
+CONFIG_SENSORS_ARM_SCPI=y
+CONFIG_SENSORS_F75375S=y
+CONFIG_SENSORS_LM75=y
+CONFIG_SENSORS_LM90=m
+CONFIG_SENSORS_PWM_FAN=m
+CONFIG_SENSORS_INA2XX=m
+CONFIG_SENSORS_INA3221=m
+CONFIG_THERMAL_WRITABLE_TRIPS=y
+CONFIG_THERMAL_GOV_POWER_ALLOCATOR=y
+CONFIG_CPU_THERMAL=y
+CONFIG_THERMAL_EMULATION=y
+CONFIG_IMX_SC_THERMAL=y
+CONFIG_DEVICE_THERMAL=y
+CONFIG_IMX8MM_THERMAL=y
+CONFIG_QORIQ_THERMAL=y
+CONFIG_WATCHDOG=y
+CONFIG_ARM_SP805_WATCHDOG=y
+CONFIG_ARM_SBSA_WATCHDOG=y
+CONFIG_DW_WATCHDOG=y
+CONFIG_IMX2_WDT=y
+CONFIG_IMX_SC_WDT=y
+CONFIG_XEN_WDT=y
+CONFIG_MFD_BD9571MWV=y
+CONFIG_MFD_AXP20X_I2C=y
+CONFIG_MFD_IMX_AUDIOMIX=y
+CONFIG_MFD_HI6421_PMIC=y
+CONFIG_MFD_MAX77620=y
+CONFIG_MFD_RK808=y
+CONFIG_MFD_SEC_CORE=y
+CONFIG_MFD_ROHM_BD718XX=y
+CONFIG_MFD_PCA9450=y
+CONFIG_REGULATOR=y
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_REGULATOR_USERSPACE_CONSUMER=y
+CONFIG_REGULATOR_AXP20X=y
+CONFIG_REGULATOR_BD718XX=y
+CONFIG_REGULATOR_BD9571MWV=y
+CONFIG_REGULATOR_FAN53555=y
+CONFIG_REGULATOR_GPIO=y
+CONFIG_REGULATOR_HI6421V530=y
+CONFIG_REGULATOR_MAX77620=y
+CONFIG_REGULATOR_MAX8973=y
+CONFIG_REGULATOR_PCA9450=y
+CONFIG_REGULATOR_PFUZE100=y
+CONFIG_REGULATOR_PWM=y
+CONFIG_REGULATOR_QCOM_SPMI=y
+CONFIG_REGULATOR_RK808=y
+CONFIG_REGULATOR_S2MPS11=y
+CONFIG_REGULATOR_VCTRL=m
+CONFIG_RC_CORE=m
+CONFIG_RC_DECODERS=y
+CONFIG_RC_DEVICES=y
+CONFIG_MEDIA_SUPPORT=y
+CONFIG_MEDIA_CAMERA_SUPPORT=y
+CONFIG_MEDIA_ANALOG_TV_SUPPORT=y
+CONFIG_MEDIA_DIGITAL_TV_SUPPORT=y
+CONFIG_MEDIA_CONTROLLER=y
+CONFIG_VIDEO_V4L2_SUBDEV_API=y
+# CONFIG_DVB_NET is not set
+CONFIG_MEDIA_USB_SUPPORT=y
+CONFIG_USB_VIDEO_CLASS=m
+CONFIG_V4L_PLATFORM_DRIVERS=y
+CONFIG_VIDEO_MX8_CAPTURE=y
+CONFIG_VIDEO_MXC_CAPTURE=y
+CONFIG_VIDEO_MXC_CSI_CAMERA=y
+CONFIG_MXC_MIPI_CSI=y
+CONFIG_MXC_CAMERA_OV5640_MIPI_V2=y
+CONFIG_V4L_MEM2MEM_DRIVERS=y
+CONFIG_VIDEO_OV5640=y
+CONFIG_IMX_DPU_CORE=y
+CONFIG_IMX_LCDIF_CORE=y
+CONFIG_IMX_LCDIFV3_CORE=y
+CONFIG_DRM=y
+CONFIG_DRM_I2C_NXP_TDA998X=m
+CONFIG_DRM_MALI_DISPLAY=m
+CONFIG_DRM_NOUVEAU=m
+CONFIG_DRM_RCAR_LVDS=m
+CONFIG_DRM_PANEL_LVDS=y
+CONFIG_DRM_PANEL_SIMPLE=y
+CONFIG_DRM_PANEL_RAYDIUM_RM67191=y
+CONFIG_DRM_PANEL_SEIKO_43WVF1G=y
+CONFIG_DRM_FSL_IMX_LVDS_BRIDGE=y
+CONFIG_DRM_SII902X=m
+CONFIG_DRM_I2C_ADV7511=y
+CONFIG_DRM_NWL_MIPI_DSI=y
+CONFIG_DRM_CDNS_HDMI_CEC=y
+CONFIG_DRM_DW_HDMI_I2S_AUDIO=m
+CONFIG_DRM_DW_HDMI_GP_AUDIO=y
+CONFIG_DRM_DW_HDMI_CEC=y
+CONFIG_DRM_ITE_IT6263=y
+CONFIG_DRM_IMX=y
+CONFIG_DRM_IMX_LCDIF_MUX_DISPLAY=y
+CONFIG_DRM_IMX_PARALLEL_DISPLAY=y
+CONFIG_DRM_IMX_TVE=y
+CONFIG_DRM_IMX_LDB=y
+CONFIG_DRM_IMX8QM_LDB=y
+CONFIG_DRM_IMX8QXP_LDB=y
+CONFIG_DRM_IMX8MP_LDB=y
+CONFIG_DRM_IMX_HDMI=y
+CONFIG_DRM_IMX_SEC_DSIM=y
+CONFIG_DRM_IMX_CDNS_MHDP=y
+CONFIG_DRM_IMX_DCSS=y
+CONFIG_DRM_ETNAVIV=m
+CONFIG_DRM_HISI_HIBMC=m
+CONFIG_DRM_HISI_KIRIN=m
+CONFIG_DRM_MXSFB=y
+CONFIG_DRM_PL111=m
+CONFIG_DRM_LIMA=m
+CONFIG_DRM_PANFROST=m
+CONFIG_FB_ARMCLCD=y
+CONFIG_FB_EFI=y
+CONFIG_BACKLIGHT_GENERIC=m
+CONFIG_BACKLIGHT_PWM=y
+CONFIG_BACKLIGHT_LP855X=m
+CONFIG_BACKLIGHT_DAC5571=y
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_DYNAMIC_MINORS=y
+CONFIG_SND_USB_AUDIO=m
+CONFIG_SND_SOC=y
+CONFIG_SND_SOC_FSL_DAI=m
+CONFIG_SND_SOC_FSL_EASRC=y
+CONFIG_SND_IMX_SOC=y
+CONFIG_SND_SOC_IMX_AK4458=y
+CONFIG_SND_SOC_IMX_AK5558=y
+CONFIG_SND_SOC_IMX_AK4497=y
+CONFIG_SND_SOC_IMX_WM8960=y
+CONFIG_SND_SOC_IMX_WM8524=y
+CONFIG_SND_SOC_IMX_CS42888=y
+CONFIG_SND_SOC_IMX_MICFIL=y
+CONFIG_SND_SOC_IMX_RPMSG=y
+CONFIG_SND_SOC_IMX_MQS=y
+CONFIG_SND_SOC_IMX_SPDIF=y
+CONFIG_SND_SOC_IMX_AUDMIX=y
+CONFIG_SND_SOC_IMX_PDM_MIC=y
+CONFIG_SND_SOC_IMX_DSP=y
+CONFIG_SND_SOC_IMX_CDNHDMI=y
+CONFIG_SND_SOC_IMX_XCVR=y
+CONFIG_SND_SOC_SOF_TOPLEVEL=y
+CONFIG_SND_SOC_SOF_OF=m
+CONFIG_SND_SOC_SOF_IMX_TOPLEVEL=y
+CONFIG_SND_SOC_SOF_IMX8_SUPPORT=m
+CONFIG_SND_SOC_SOF_IMX8M_SUPPORT=m
+CONFIG_SND_SOC_AK4613=m
+CONFIG_SND_SOC_BT_SCO=y
+CONFIG_SND_SOC_DMIC=m
+CONFIG_SND_SOC_ES7134=m
+CONFIG_SND_SOC_ES7241=m
+CONFIG_SND_SOC_MAX98357A=m
+CONFIG_SND_SOC_PCM3168A_I2C=m
+CONFIG_SND_SOC_SGTL5000=m
+CONFIG_SND_SOC_SPDIF=m
+CONFIG_SND_SOC_TAS571X=m
+CONFIG_SND_SIMPLE_CARD=y
+CONFIG_SND_AUDIO_GRAPH_CARD=y
+CONFIG_HIDRAW=y
+CONFIG_UHID=y
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_REDRAGON is not set
+# CONFIG_HID_MONTEREY is not set
+CONFIG_HID_PID=y
+CONFIG_USB_HIDDEV=y
+CONFIG_I2C_HID=m
+CONFIG_USB=y
+CONFIG_USB_OTG=y
+CONFIG_USB_OTG_WHITELIST=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_HCD_PLATFORM=y
+CONFIG_USB_OHCI_HCD=y
+CONFIG_USB_OHCI_HCD_PLATFORM=y
+CONFIG_USB_HCD_TEST_MODE=y
+CONFIG_USB_ACM=m
+CONFIG_USB_STORAGE=y
+CONFIG_USB_CDNS3=y
+CONFIG_USB_CDNS3_GADGET=y
+CONFIG_USB_CDNS3_HOST=y
+CONFIG_USB_MUSB_HDRC=y
+CONFIG_USB_DWC3=y
+CONFIG_USB_DWC2=y
+CONFIG_USB_CHIPIDEA=y
+CONFIG_USB_CHIPIDEA_UDC=y
+CONFIG_USB_CHIPIDEA_HOST=y
+CONFIG_USB_ISP1760=y
+CONFIG_USB_SERIAL=y
+CONFIG_USB_SERIAL_CONSOLE=y
+CONFIG_USB_SERIAL_GENERIC=y
+CONFIG_USB_SERIAL_SIMPLE=y
+CONFIG_USB_SERIAL_FTDI_SIO=y
+CONFIG_USB_SERIAL_OPTION=m
+CONFIG_USB_TEST=m
+CONFIG_USB_EHSET_TEST_FIXTURE=m
+CONFIG_USB_HSIC_USB3503=y
+CONFIG_NOP_USB_XCEIV=y
+CONFIG_USB_MXS_PHY=y
+CONFIG_USB_ULPI=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_SNP_UDC_PLAT=y
+CONFIG_USB_BDC_UDC=y
+CONFIG_USB_CONFIGFS=y
+CONFIG_USB_CONFIGFS_SERIAL=y
+CONFIG_USB_CONFIGFS_ACM=y
+CONFIG_USB_CONFIGFS_OBEX=y
+CONFIG_USB_CONFIGFS_NCM=y
+CONFIG_USB_CONFIGFS_ECM=y
+CONFIG_USB_CONFIGFS_ECM_SUBSET=y
+CONFIG_USB_CONFIGFS_RNDIS=y
+CONFIG_USB_CONFIGFS_EEM=y
+CONFIG_USB_CONFIGFS_MASS_STORAGE=y
+CONFIG_USB_CONFIGFS_F_LB_SS=y
+CONFIG_USB_CONFIGFS_F_FS=y
+CONFIG_USB_CONFIGFS_F_UAC1=y
+CONFIG_USB_CONFIGFS_F_UAC1_LEGACY=y
+CONFIG_USB_CONFIGFS_F_UAC2=y
+CONFIG_USB_CONFIGFS_F_MIDI=y
+CONFIG_USB_CONFIGFS_F_HID=y
+CONFIG_USB_CONFIGFS_F_UVC=y
+CONFIG_USB_ZERO=m
+CONFIG_USB_AUDIO=m
+CONFIG_USB_ETH=m
+CONFIG_USB_MASS_STORAGE=m
+CONFIG_USB_G_SERIAL=m
+CONFIG_MMC=y
+CONFIG_MMC_BLOCK_MINORS=32
+CONFIG_MMC_ARMMMCI=y
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_ACPI=y
+CONFIG_MMC_SDHCI_PLTFM=y
+CONFIG_MMC_SDHCI_OF_ARASAN=y
+CONFIG_MMC_SDHCI_OF_ESDHC=y
+CONFIG_MMC_SDHCI_CADENCE=y
+CONFIG_MMC_SDHCI_ESDHC_IMX=y
+CONFIG_MMC_SDHCI_F_SDH30=y
+CONFIG_MMC_SPI=y
+CONFIG_MMC_DW=y
+CONFIG_MMC_DW_EXYNOS=y
+CONFIG_MMC_DW_HI3798CV200=y
+CONFIG_MMC_DW_K3=y
+CONFIG_MMC_SDHCI_XENON=y
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_BRIGHTNESS_HW_CHANGED=y
+CONFIG_LEDS_GPIO=y
+CONFIG_LEDS_PWM=y
+CONFIG_LEDS_SYSCON=y
+CONFIG_LEDS_USER=y
+CONFIG_LEDS_TRIGGER_TIMER=y
+CONFIG_LEDS_TRIGGER_ONESHOT=y
+CONFIG_LEDS_TRIGGER_DISK=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+CONFIG_LEDS_TRIGGER_CPU=y
+CONFIG_LEDS_TRIGGER_GPIO=y
+CONFIG_LEDS_TRIGGER_DEFAULT_ON=y
+CONFIG_LEDS_TRIGGER_PANIC=y
+CONFIG_LEDS_TRIGGER_PATTERN=y
+CONFIG_EDAC=y
+CONFIG_EDAC_GHES=y
+CONFIG_EDAC_SYNOPSYS=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc1"
+CONFIG_RTC_DRV_DS1307=y
+CONFIG_RTC_DRV_MAX77686=y
+CONFIG_RTC_DRV_RK808=m
+CONFIG_RTC_DRV_PCF85363=y
+CONFIG_RTC_DRV_S35390A=y
+CONFIG_RTC_DRV_RX8581=m
+CONFIG_RTC_DRV_S5M=y
+CONFIG_RTC_DRV_DS3232=y
+CONFIG_RTC_DRV_PCF2127=y
+CONFIG_RTC_DRV_EFI=y
+CONFIG_RTC_DRV_CROS_EC=y
+CONFIG_RTC_DRV_PL031=y
+CONFIG_RTC_DRV_SNVS=y
+CONFIG_RTC_DRV_IMX_SC=y
+CONFIG_DMADEVICES=y
+CONFIG_BCM_SBA_RAID=m
+CONFIG_FSL_EDMA=y
+CONFIG_FSL_EDMA_V3=y
+CONFIG_IMX_SDMA=y
+CONFIG_MV_XOR_V2=y
+CONFIG_MXS_DMA=y
+CONFIG_PL330_DMA=y
+CONFIG_QCOM_HIDMA_MGMT=y
+CONFIG_QCOM_HIDMA=y
+CONFIG_DMATEST=y
+CONFIG_UIO=y
+CONFIG_UIO_PCI_GENERIC=y
+CONFIG_UIO_IVSHMEM=y
+CONFIG_VFIO=y
+CONFIG_VFIO_PCI=y
+CONFIG_VFIO_FSL_MC=y
+CONFIG_VIRTIO_PCI=y
+CONFIG_VIRTIO_BALLOON=y
+CONFIG_VIRTIO_MMIO=y
+CONFIG_XEN_GNTDEV=y
+CONFIG_XEN_GRANT_DEV_ALLOC=y
+CONFIG_STAGING=y
+CONFIG_STAGING_MEDIA=y
+CONFIG_VIDEO_IMX_CAPTURE=y
+CONFIG_ION=y
+CONFIG_ION_SYSTEM_HEAP=y
+CONFIG_ION_CMA_HEAP=y
+CONFIG_FSL_DPAA2=y
+CONFIG_FSL_DPAA2_ETHSW=y
+CONFIG_FSL_DPAA2_MAC=y
+CONFIG_FSL_SDK_DPA=y
+CONFIG_FSL_PPFE=y
+CONFIG_FSL_PPFE_UTIL_DISABLED=y
+CONFIG_MFD_CROS_EC=y
+CONFIG_CROS_EC_I2C=y
+CONFIG_CROS_EC_SPI=y
+CONFIG_COMMON_CLK_VERSATILE=y
+CONFIG_CLK_SP810=y
+CONFIG_CLK_VEXPRESS_OSC=y
+CONFIG_COMMON_CLK_RK808=y
+CONFIG_COMMON_CLK_SCPI=y
+CONFIG_COMMON_CLK_CS2000_CP=y
+CONFIG_COMMON_CLK_S2MPS11=y
+CONFIG_COMMON_CLK_XGENE=y
+CONFIG_COMMON_CLK_PWM=y
+CONFIG_CLK_IMX8MM=y
+CONFIG_CLK_IMX8MN=y
+CONFIG_CLK_IMX8MP=y
+CONFIG_CLK_IMX8MQ=y
+CONFIG_CLK_IMX8QXP=y
+CONFIG_HWSPINLOCK=y
+CONFIG_ARM_MHU=y
+CONFIG_IMX_MBOX=y
+CONFIG_PLATFORM_MHU=y
+CONFIG_ARM_SMMU=y
+CONFIG_ARM_SMMU_V3=y
+CONFIG_REMOTEPROC=y
+CONFIG_IMX_REMOTEPROC=y
+CONFIG_RPMSG_QCOM_GLINK_RPM=y
+CONFIG_SOC_BRCMSTB=y
+CONFIG_FSL_MC_DPIO=y
+CONFIG_FSL_QIXIS=y
+CONFIG_IMX_SCU_SOC=y
+CONFIG_SECVIO_SC=y
+CONFIG_SOC_TI=y
+CONFIG_EXTCON_USB_GPIO=y
+CONFIG_EXTCON_USBC_CROS_EC=y
+CONFIG_IIO=y
+CONFIG_IMX8QXP_ADC=y
+CONFIG_IIO_CROS_EC_SENSORS_CORE=m
+CONFIG_IIO_CROS_EC_SENSORS=m
+CONFIG_IIO_CROS_EC_LIGHT_PROX=m
+CONFIG_IIO_CROS_EC_BARO=m
+CONFIG_PWM=y
+CONFIG_PWM_CROS_EC=m
+CONFIG_PWM_IMX27=y
+CONFIG_PHY_XGENE=y
+CONFIG_PHY_MIXEL_LVDS=y
+CONFIG_PHY_MIXEL_LVDS_COMBO=y
+CONFIG_PHY_FSL_IMX8MP_LVDS=y
+CONFIG_PHY_MIXEL_MIPI_DPHY=y
+CONFIG_PHY_SAMSUNG_HDMI_PHY=y
+CONFIG_PHY_QCOM_USB_HS=y
+CONFIG_PHY_SAMSUNG_USB2=y
+CONFIG_FSL_IMX8_DDR_PMU=y
+CONFIG_HISI_PMU=y
+CONFIG_NVMEM_IMX_OCOTP=y
+CONFIG_NVMEM_IMX_OCOTP_SCU=y
+CONFIG_FPGA=y
+CONFIG_FPGA_BRIDGE=m
+CONFIG_ALTERA_FREEZE_BRIDGE=m
+CONFIG_FPGA_REGION=m
+CONFIG_OF_FPGA_REGION=m
+CONFIG_TEE=y
+CONFIG_OPTEE=y
+CONFIG_MUX_MMIO=y
+CONFIG_MXC_SIM=y
+CONFIG_MXC_EMVSIM=y
+CONFIG_MXC_MLB150=y
+CONFIG_EXT2_FS=y
+CONFIG_EXT3_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_BTRFS_FS=m
+CONFIG_BTRFS_FS_POSIX_ACL=y
+CONFIG_FANOTIFY=y
+CONFIG_FANOTIFY_ACCESS_PERMISSIONS=y
+CONFIG_QUOTA=y
+CONFIG_AUTOFS4_FS=y
+CONFIG_FUSE_FS=m
+CONFIG_CUSE=m
+CONFIG_OVERLAY_FS=m
+CONFIG_VFAT_FS=y
+CONFIG_HUGETLBFS=y
+CONFIG_EFIVAR_FS=y
+CONFIG_JFFS2_FS=y
+CONFIG_UBIFS_FS=y
+CONFIG_SQUASHFS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V4=y
+CONFIG_NFS_V4_1=y
+CONFIG_NFS_V4_2=y
+CONFIG_ROOT_NFS=y
+CONFIG_9P_FS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_SECURITY=y
+CONFIG_CRYPTO_USER=y
+CONFIG_CRYPTO_TEST=m
+CONFIG_CRYPTO_CHACHA20POLY1305=m
+CONFIG_CRYPTO_ECHAINIV=y
+CONFIG_CRYPTO_TLS=m
+CONFIG_CRYPTO_CBC=m
+CONFIG_CRYPTO_CFB=m
+CONFIG_CRYPTO_CTS=m
+CONFIG_CRYPTO_LRW=m
+CONFIG_CRYPTO_OFB=m
+CONFIG_CRYPTO_PCBC=m
+CONFIG_CRYPTO_XTS=m
+CONFIG_CRYPTO_XCBC=m
+CONFIG_CRYPTO_VMAC=m
+CONFIG_CRYPTO_MD4=m
+CONFIG_CRYPTO_MD5=m
+CONFIG_CRYPTO_RMD128=m
+CONFIG_CRYPTO_RMD160=m
+CONFIG_CRYPTO_RMD256=m
+CONFIG_CRYPTO_RMD320=m
+CONFIG_CRYPTO_SHA512=m
+CONFIG_CRYPTO_STREEBOG=m
+CONFIG_CRYPTO_TGR192=m
+CONFIG_CRYPTO_WP512=m
+CONFIG_CRYPTO_ANUBIS=m
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_CAMELLIA=m
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
+CONFIG_CRYPTO_FCRYPT=m
+CONFIG_CRYPTO_KHAZAD=m
+CONFIG_CRYPTO_SALSA20=m
+CONFIG_CRYPTO_SEED=m
+CONFIG_CRYPTO_SERPENT=m
+CONFIG_CRYPTO_SM4=m
+CONFIG_CRYPTO_TEA=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_ANSI_CPRNG=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_SECVIO=y
+CONFIG_CRYPTO_DEV_FSL_CAAM=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_SM=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_SM_TEST=m
+CONFIG_CRYPTO_DEV_FSL_DPAA2_CAAM=y
+CONFIG_INDIRECT_PIO=y
+CONFIG_CMA_SIZE_MBYTES=320
+CONFIG_PRINTK_TIME=y
+CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_FS=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_DEBUG_PREEMPT is not set
+# CONFIG_FTRACE is not set
+CONFIG_MEMTEST=y
+CONFIG_CORESIGHT=y
+CONFIG_CORESIGHT_LINK_AND_SINK_TMC=y
+CONFIG_CORESIGHT_SOURCE_ETM4X=y
diff --git a/dfi-release-2021-08-06 b/dfi-release-2021-08-06
new file mode 100644
index 000000000..e69de29bb
diff --git a/drivers/clk/imx/clk-imx8mp.c b/drivers/clk/imx/clk-imx8mp.c
index b640d2aad..55bd2a98e 100644
--- a/drivers/clk/imx/clk-imx8mp.c
+++ b/drivers/clk/imx/clk-imx8mp.c
@@ -13,6 +13,7 @@
 #include <linux/platform_device.h>
 #include <linux/slab.h>
 #include <linux/types.h>
+#include <linux/debugfs.h>
 #include <soc/imx/soc.h>
 
 #include "clk.h"
@@ -498,6 +499,480 @@ static const char *imx8mp_dram_core_sels[] = {"dram_pll_out", "dram_alt_root", }
 static struct clk *clks[IMX8MP_CLK_END];
 static struct clk_onecell_data clk_data;
 
+#define VIDEO_PLL_SSCG 31
+#define SSCG_EN 1
+#define VIDEO_PLL_MFREQ_CTL 12
+#define VIDEO_PLL_MRAT_CTL 4
+#define VIDEO_PLL_SEL_PF 0
+#define SEL_PF_DOWN_SP 0
+#define SEL_PF_UP_SP 1
+#define SEL_PF_CEN_SP 2
+
+struct videppll_sscm {
+	struct device *dev;
+	struct device_node *np;
+	void __iomem *base;
+	unsigned int mdiv, pdiv;
+	unsigned int mfr, mrr, mr, mf, pf;
+	unsigned int sccm_enable;
+};
+
+
+static int sscm_pf_dfs_open(struct inode *inode, struct file *file)
+{
+	file->private_data = inode->i_private;
+	return 0;
+}
+
+static ssize_t sscm_pf_dfs_read(struct file *file,
+					char __user *usr_buf,
+					size_t size, loff_t *ppos)
+{
+	struct videppll_sscm *_videppll_sscm;
+	int cnt;
+	int pf;
+	char buf[10];
+
+	_videppll_sscm = file->private_data;
+	if (!_videppll_sscm) {
+		dev_err(_videppll_sscm->dev, "_videppll_sscm null\n");
+		return 0;
+	}
+
+	if (*ppos != 0)
+		return 0;
+
+	pf = _videppll_sscm->pf;
+	cnt = snprintf(buf, sizeof(buf), "%d\n", pf);
+
+	return simple_read_from_buffer(usr_buf, size, ppos, buf, cnt);
+}
+
+static ssize_t sscm_pf_dfs_write(struct file *file,
+					 const char __user *usr_buf,
+					 size_t size, loff_t *ppos)
+{
+	struct videppll_sscm *_videppll_sscm;
+	int ret;
+	unsigned int pf;
+
+	ret = kstrtoint_from_user(usr_buf, size, 0, &pf);
+	if (ret)
+		return ret;
+
+	if (pf < 0 || pf > 1)
+		return -EINVAL;
+
+	_videppll_sscm = file->private_data;
+	if (!_videppll_sscm) {
+		dev_err(_videppll_sscm->dev, "_videppll_sscm null\n");
+		return 0;
+	}
+
+	_videppll_sscm->pf = pf;
+
+	return size;
+}
+
+static const struct file_operations debugfs_sscm_pf_fops = {
+	.owner = THIS_MODULE,
+	.open = sscm_pf_dfs_open,
+	.read = sscm_pf_dfs_read,
+	.write = sscm_pf_dfs_write,
+	.llseek  = seq_lseek,
+};
+
+
+static int sscm_enable_dfs_open(struct inode *inode, struct file *file)
+{
+	file->private_data = inode->i_private;
+	return 0;
+}
+
+static ssize_t sscm_enable_dfs_read(struct file *file,
+					char __user *usr_buf,
+					size_t size, loff_t *ppos)
+{
+	struct videppll_sscm *_videppll_sscm;
+	int cnt;
+	int enable;
+	char buf[10];
+
+	_videppll_sscm = file->private_data;
+	if (!_videppll_sscm) {
+		dev_err(_videppll_sscm->dev, "_videppll_sscm null\n");
+		return 0;
+	}
+
+	if (*ppos != 0)
+		return 0;
+
+	enable = _videppll_sscm->sccm_enable;
+	cnt = snprintf(buf, sizeof(buf), "%d\n", enable);
+
+	return simple_read_from_buffer(usr_buf, size, ppos, buf, cnt);
+}
+
+static ssize_t sscm_enable_dfs_write(struct file *file,
+					 const char __user *usr_buf,
+					 size_t size, loff_t *ppos)
+{
+	struct videppll_sscm *_videppll_sscm;
+	int enable, ret;
+	unsigned int val, mfr, mrr, pf;
+
+	ret = kstrtoint_from_user(usr_buf, size, 0, &enable);
+	if (ret)
+		return ret;
+
+	if (enable < 0)
+		return -EINVAL;
+
+	_videppll_sscm = file->private_data;
+	if (!_videppll_sscm) {
+		dev_err(_videppll_sscm->dev, "_videppll_sscm null\n");
+		return 0;
+	}
+
+
+	mfr = _videppll_sscm->mfr;
+	mrr = _videppll_sscm->mrr;
+	pf = _videppll_sscm->pf;
+
+	val = (mfr << VIDEO_PLL_MFREQ_CTL | \
+			mrr << VIDEO_PLL_MRAT_CTL | \
+			pf << VIDEO_PLL_SEL_PF);
+
+	writel(val, _videppll_sscm->base);
+
+	if (enable) {
+		val |= SSCG_EN << VIDEO_PLL_SSCG;
+		_videppll_sscm->sccm_enable = 1;
+	} else {
+		val &= ~SSCG_EN << VIDEO_PLL_SSCG;
+		_videppll_sscm->sccm_enable = 0;
+	}
+
+	writel(val, _videppll_sscm->base);
+
+	return size;
+}
+
+static const struct file_operations debugfs_sscm_en_fops = {
+	.owner = THIS_MODULE,
+	.open = sscm_enable_dfs_open,
+	.read = sscm_enable_dfs_read,
+	.write = sscm_enable_dfs_write,
+	.llseek  = seq_lseek,
+};
+
+static int sscm_mf_dfs_open(struct inode *inode, struct file *file)
+{
+	file->private_data = inode->i_private;
+	return 0;
+}
+
+static ssize_t sscm_mf_dfs_read(struct file *file,
+					char __user *usr_buf,
+					size_t size, loff_t *ppos)
+{
+	struct videppll_sscm *_videppll_sscm;
+	int cnt;
+	unsigned int mf;
+	char buf[10];
+
+	_videppll_sscm = file->private_data;
+	if (!_videppll_sscm) {
+		dev_err(_videppll_sscm->dev, "_videppll_sscm null\n");
+		return 0;
+	}
+
+	if (*ppos != 0)
+		return 0;
+
+	mf = _videppll_sscm->mf;
+	cnt = snprintf(buf, sizeof(buf), "%d\n", mf);
+
+	return simple_read_from_buffer(usr_buf, size, ppos, buf, cnt);
+}
+
+static ssize_t sscm_mf_dfs_write(struct file *file,
+					 const char __user *usr_buf,
+					 size_t size, loff_t *ppos)
+{
+	struct videppll_sscm *_videppll_sscm;
+	unsigned int sccm_enable, mf, mfr, pdiv;
+	int ret;
+	long tmp;
+
+	ret = kstrtoint_from_user(usr_buf, size, 0, &mf);
+	if (ret)
+		return ret;
+
+	if (!mf)
+		return -EINVAL;
+
+	_videppll_sscm = file->private_data;
+	if (!_videppll_sscm) {
+		dev_err(_videppll_sscm->dev, "_videppll_sscm null\n");
+		return 0;
+	}
+
+	sccm_enable = _videppll_sscm->sccm_enable;
+	if (sccm_enable) {
+		dev_warn(_videppll_sscm->dev, "please disable sccm\n");
+		return size;
+	}
+
+	pdiv = _videppll_sscm->pdiv;
+	pr_info("SLASH pdiv %d\n", pdiv);
+	tmp = (mf << 5) * pdiv;
+	mfr = DIV_ROUND_CLOSEST(24000000, tmp);
+	if (mfr > 255 || mfr == 0) {
+		dev_warn(_videppll_sscm->dev,
+			"mfr overflow %d, change to 255\n", mfr);
+		mfr = 255;
+	}
+
+	_videppll_sscm->mfr = mfr;
+	_videppll_sscm->mf = mf;
+
+	return size;
+}
+
+static const struct file_operations debugfs_sscm_mf_fops = {
+	.owner = THIS_MODULE,
+	.open = sscm_mf_dfs_open,
+	.read = sscm_mf_dfs_read,
+	.write = sscm_mf_dfs_write,
+	.llseek  = seq_lseek,
+};
+
+static int sscm_mr_dfs_open(struct inode *inode, struct file *file)
+{
+	file->private_data = inode->i_private;
+	return 0;
+}
+
+static ssize_t sscm_mr_dfs_read(struct file *file,
+					char __user *usr_buf,
+					size_t size, loff_t *ppos)
+{
+	struct videppll_sscm *_videppll_sscm;
+	int cnt;
+	unsigned int mr;
+	char buf[10];
+
+	_videppll_sscm = file->private_data;
+	if (!_videppll_sscm) {
+		dev_err(_videppll_sscm->dev, "_videppll_sscm null\n");
+		return 0;
+	}
+
+	if (*ppos != 0)
+		return 0;
+	mr = _videppll_sscm->mr;
+	cnt = snprintf(buf, sizeof(buf), "%d\n", mr);
+
+	return simple_read_from_buffer(usr_buf, size, ppos, buf, cnt);
+}
+
+static ssize_t sscm_mr_dfs_write(struct file *file,
+					 const char __user *usr_buf,
+					 size_t size, loff_t *ppos)
+{
+	struct videppll_sscm *_videppll_sscm;
+	unsigned int mr, mrr, mdiv, ret;
+	unsigned int sccm_enable;
+	long tmp;
+
+	ret = kstrtoint_from_user(usr_buf, size, 0, &mr);
+	if (ret)
+		return ret;
+
+	if (!mr)
+		return -EINVAL;
+
+	_videppll_sscm = file->private_data;
+	if (!_videppll_sscm) {
+		dev_err(_videppll_sscm->dev, "_videppll_sscm null\n");
+		return 0;
+	}
+
+	sccm_enable = _videppll_sscm->sccm_enable;
+	if (sccm_enable) {
+		dev_warn(_videppll_sscm->dev, "please disable sccm\n");
+		return size;
+	}
+
+	mdiv = _videppll_sscm->mdiv;
+	tmp = mr * (mdiv << 6);
+	mrr = DIV_ROUND_CLOSEST(tmp, _videppll_sscm->mfr);
+
+	/* exaggeration of 100 times for MR, so it have to return orginal */
+	mrr = DIV_ROUND_CLOSEST(mrr, 10000);
+	if (mrr > 63) {
+		dev_warn(_videppll_sscm->dev,
+			"mrr overflow %d, change to 63\n", mrr);
+		mrr = 63;
+	}
+
+	_videppll_sscm->mr = mr;
+	_videppll_sscm->mrr = mrr;
+
+	return size;
+}
+
+static const struct file_operations debugfs_sscm_mr_fops = {
+	.owner = THIS_MODULE,
+	.open = sscm_mr_dfs_open,
+	.read = sscm_mr_dfs_read,
+	.write = sscm_mr_dfs_write,
+	.llseek  = seq_lseek,
+};
+
+static int enable_sscm(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	struct clk *video_pll_clk;
+	struct dentry *sscm_dbg_dir;
+	void __iomem *base;
+	unsigned int val, i;
+	unsigned int mdiv, pdiv;
+	unsigned int mfr, mrr, mr, mf, pf;
+	long tmp;
+	struct videppll_sscm *_videppll_sscm;
+
+	dev_info(&pdev->dev, "enable_sscm\n");
+	np = of_find_compatible_node(NULL, NULL, "fsl,imx8mp-videopll-sscm");
+	if (!np) {
+		dev_info(&pdev->dev, "enable_sscm disable\n");
+		return -EINVAL;
+	}
+
+	_videppll_sscm = kmalloc(sizeof(struct videppll_sscm), GFP_KERNEL);
+	if (!_videppll_sscm) {
+		dev_err(&pdev->dev, "unable to create _videppll_sscm\n");
+		return -ENOMEM;
+	}
+
+	_videppll_sscm->sccm_enable = 0;
+
+	base = of_iomap(np, 0);
+	if (WARN_ON(!base))
+		return -ENOMEM;
+
+	_videppll_sscm->base = base;
+
+	video_pll_clk = of_clk_get_by_name(np, "video_pll1");
+	if (!video_pll_clk) {
+		dev_err(&pdev->dev, "unable to get video_pll_clks\n");
+		return -ENOMEM;
+	}
+
+	val = clk_get_rate(video_pll_clk);
+	for (i = 0; i < imx8mp_video_pll.rate_count; i++)
+		if (val == imx8mp_video_pll.rate_table[i].rate)
+			break;
+
+	if (of_property_read_u32(np, "mf", &mf)) {
+		dev_err(&pdev->dev, "unable to get mfr val\n");
+		return -EINVAL;
+	}
+	_videppll_sscm->mf = mf;
+
+	if (of_property_read_u32(np, "mr", &mr)) {
+		dev_err(&pdev->dev, "unable to get mfr val\n");
+		return -EINVAL;
+	}
+	_videppll_sscm->mr = mr;
+
+	if (of_property_read_u32(np, "pf", &pf)) {
+		dev_err(&pdev->dev, "unable to get pf val\n");
+		return -EINVAL;
+	}
+	_videppll_sscm->pf = pf;
+
+	mdiv = imx8mp_video_pll.rate_table[i].mdiv;
+	pdiv = imx8mp_video_pll.rate_table[i].pdiv;
+	_videppll_sscm->mdiv = mdiv;
+	_videppll_sscm->pdiv = pdiv;
+
+	/*
+	 * Value of modulation frequency control Modulation Frequency,
+	 * MF is determined by the following equation:
+	 *
+	 * MF = F FIN /p/mfr/(2^5) Hz
+	 *
+	 * F FIN is the PLL input clock frequency,
+	 *
+	 * mfr is the decimal value for PLL_MFREQ_CTL[7:0], and
+	 * p is the decimal value for PLL_PRE_DIV.
+	 *
+	 */
+	tmp = (mf << 5) * pdiv;
+	mfr = DIV_ROUND_CLOSEST(24000000, tmp);
+	if (mfr > 255) {
+		dev_warn(&pdev->dev, "mfr overflow %d, change to 255\n", mfr);
+		mfr = 255;
+	}
+
+	/* Value of modulation rate control
+	 * Modulation rate (pk-pk), MR, is determined by the following :
+	 *
+	 * MR = mfr x mrr /m /(2^6) x 100 [%]
+	 *
+	 * mfr is the decimal value of PLL_MFREQ_CTL,
+	 * mrr is the decimal value for PLL_MRAT_CTL[5:0]
+	 * and m is the decimal of PLL_MAIN_DIV.
+	 */
+	tmp = mr * (mdiv << 6);
+	mrr = DIV_ROUND_CLOSEST(tmp, mfr);
+
+	/* exaggeration of 100 times for MR, so it have to return orginal */
+	mrr = DIV_ROUND_CLOSEST(mrr, 10000);
+	if (mrr > 63) {
+		dev_warn(&pdev->dev, "mrr overflow %d, change to 63\n", mrr);
+		mrr = 63;
+	}
+
+	dev_info(&pdev->dev, "mfr %d, mrr %d\n", mfr, mrr);
+
+	val = (mfr << VIDEO_PLL_MFREQ_CTL | \
+			mrr << VIDEO_PLL_MRAT_CTL | \
+			pf << VIDEO_PLL_SEL_PF);
+
+	_videppll_sscm->mfr = mfr;
+	_videppll_sscm->mrr = mrr;
+
+	writel(val, base);
+
+	val |= SSCG_EN << VIDEO_PLL_SSCG;
+	writel(val, base);
+
+	_videppll_sscm->dev = &pdev->dev;
+	_videppll_sscm->sccm_enable = 1;
+
+	sscm_dbg_dir = debugfs_create_dir("sscm_debugfs", NULL);
+	debugfs_create_file("module-frequency", S_IWUSR | S_IRUSR,
+			    sscm_dbg_dir, _videppll_sscm, &debugfs_sscm_mf_fops);
+
+	debugfs_create_file("module-rate", S_IWUSR | S_IRUSR,
+			    sscm_dbg_dir, _videppll_sscm, &debugfs_sscm_mr_fops);
+
+
+	debugfs_create_file("enable", S_IWUSR | S_IRUSR,
+			    sscm_dbg_dir, _videppll_sscm, &debugfs_sscm_en_fops);
+
+	debugfs_create_file("profile_sel", S_IWUSR | S_IRUSR,
+			    sscm_dbg_dir, _videppll_sscm, &debugfs_sscm_pf_fops);
+
+	dev_info(&pdev->dev, "MF=%d, MR=%d\n", mf, mr);
+	dev_info(&pdev->dev, "MFR=%d MRR=%d\n", mfr, mrr);
+	return 0;
+}
+
 static int __init imx_clk_init_on(struct device_node *np,
 				  struct clk * const clks[])
 {
@@ -867,6 +1342,10 @@ static int imx8mp_clocks_probe(struct platform_device *pdev)
 
 	imx_register_uart_clocks();
 
+	ret = enable_sscm(pdev);
+	if (ret)
+		pr_err("enable_sscm fail\n");
+
 	pr_info("i.MX8MP clock driver probe done\n");
 
 	return 0;
diff --git a/drivers/gpu/drm/imx/imx8mp-ldb.c b/drivers/gpu/drm/imx/imx8mp-ldb.c
index c26f8dc83..f48df0e20 100644
--- a/drivers/gpu/drm/imx/imx8mp-ldb.c
+++ b/drivers/gpu/drm/imx/imx8mp-ldb.c
@@ -9,6 +9,7 @@
 #include <linux/of_device.h>
 #include <linux/phy/phy.h>
 
+#include <linux/delay.h>
 #include <drm/bridge/fsl_imx_ldb.h>
 #include <drm/drm_atomic_helper.h>
 #include <drm/drm_probe_helper.h>
@@ -59,6 +60,7 @@ struct imx8mp_ldb {
 	struct ldb base;
 	struct imx8mp_ldb_channel channel[LDB_CH_NUM];
 	struct clk *clk_root;
+	u32 startup_delay;
 };
 
 static struct drm_encoder *imx8mp_ldb_connector_best_encoder(
@@ -77,6 +79,9 @@ static void imx8mp_ldb_encoder_enable(struct drm_encoder *encoder)
 	struct imx8mp_ldb *imx8mp_ldb = imx8mp_ldb_ch->imx8mp_ldb;
 	struct ldb *ldb = &imx8mp_ldb->base;
 
+	if (imx8mp_ldb->startup_delay > 0)
+		msleep(imx8mp_ldb->startup_delay);
+
 	clk_prepare_enable(imx8mp_ldb->clk_root);
 
 	if (imx8mp_ldb_ch == &imx8mp_ldb->channel[0] || ldb->dual) {
@@ -396,11 +401,17 @@ static int imx8mp_ldb_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
 	struct imx8mp_ldb *imx8mp_ldb;
+	int ret;
 
 	imx8mp_ldb = devm_kzalloc(dev, sizeof(*imx8mp_ldb), GFP_KERNEL);
 	if (!imx8mp_ldb)
 		return -ENOMEM;
 
+	ret = of_property_read_u32(dev->of_node,
+		"startup-delay-us", &imx8mp_ldb->startup_delay);
+	if (ret)
+		imx8mp_ldb->startup_delay = 0;
+
 	dev_set_drvdata(dev, imx8mp_ldb);
 
 	return component_add(dev, &imx8mp_ldb_ops);
diff --git a/drivers/gpu/drm/panel/panel-lvds.c b/drivers/gpu/drm/panel/panel-lvds.c
index bf5fcc3e5..817114e7b 100644
--- a/drivers/gpu/drm/panel/panel-lvds.c
+++ b/drivers/gpu/drm/panel/panel-lvds.c
@@ -16,6 +16,7 @@
 #include <linux/regulator/consumer.h>
 #include <linux/slab.h>
 
+#include <linux/delay.h>
 #include <video/display_timing.h>
 #include <video/of_display_timing.h>
 #include <video/videomode.h>
@@ -23,6 +24,8 @@
 #include <drm/drm_crtc.h>
 #include <drm/drm_panel.h>
 
+#define BL_VOLT_MAX 3300000
+#define BL_VOLT_MIN 0000001
 struct panel_lvds {
 	struct drm_panel panel;
 	struct device *dev;
@@ -39,6 +42,7 @@ struct panel_lvds {
 
 	struct gpio_desc *enable_gpio;
 	struct gpio_desc *reset_gpio;
+	u32 bl_delay;
 };
 
 static inline struct panel_lvds *to_panel_lvds(struct drm_panel *panel)
@@ -87,6 +91,8 @@ static int panel_lvds_prepare(struct drm_panel *panel)
 		}
 	}
 
+	regulator_set_voltage(lvds->supply, BL_VOLT_MAX, BL_VOLT_MAX);
+
 	if (lvds->enable_gpio)
 		gpiod_set_value_cansleep(lvds->enable_gpio, 1);
 
@@ -103,6 +109,7 @@ static int panel_lvds_enable(struct drm_panel *panel)
 		backlight_update_status(lvds->backlight);
 	}
 
+	msleep(lvds->bl_delay);
 	return 0;
 }
 
@@ -191,6 +198,10 @@ static int panel_lvds_parse_dt(struct panel_lvds *lvds)
 
 	lvds->data_mirror = of_property_read_bool(np, "data-mirror");
 
+	ret = of_property_read_u32(np, "backlight-delay", &lvds->bl_delay);
+	if (ret < 0)
+		lvds->bl_delay = 0;
+
 	return 0;
 }
 
diff --git a/drivers/hwmon/f75375s.c b/drivers/hwmon/f75375s.c
index eb847a7d6..91155781f 100644
--- a/drivers/hwmon/f75375s.c
+++ b/drivers/hwmon/f75375s.c
@@ -25,6 +25,7 @@
 #include <linux/mutex.h>
 #include <linux/f75375s.h>
 #include <linux/slab.h>
+#include <linux/of_graph.h>
 
 /* Addresses to scan */
 static const unsigned short normal_i2c[] = { 0x2d, 0x2e, I2C_CLIENT_END };
@@ -34,8 +35,15 @@ enum chips { f75373, f75375, f75387 };
 /* Fintek F75375 registers  */
 #define F75375_REG_CONFIG0		0x0
 #define F75375_REG_CONFIG1		0x1
+
 #define F75375_REG_CONFIG2		0x2
+#define CONFIG2_PIN5_MODE		6
+#define CONFIG2_PIN5_MODE_MASK	0x3
+
 #define F75375_REG_CONFIG3		0x3
+#define CONFIG3_PIN6_MODE		6
+#define CONFIG3_PIN6_MODE_MASK	0x3
+
 #define F75375_REG_ADDR			0x4
 #define F75375_REG_INTR			0x31
 #define F75375_CHIP_ID			0x5A
@@ -43,6 +51,12 @@ enum chips { f75373, f75375, f75387 };
 #define F75375_REG_VENDOR		0x5D
 #define F75375_REG_FAN_TIMER		0x60
 
+#define F75387_REG_REAL_TIME_FAULT_SAT	0x36
+#define FAN_FAULT_MECH_MASK 0x3
+#define FAN_FAULT_MECH_OFF 6
+#define TEMP_FAULT_MECH_MASK 0x3
+#define TEMP_FAULT_MECH_OFF 4
+
 #define F75375_REG_VOLT(nr)		(0x10 + (nr))
 #define F75375_REG_VOLT_HIGH(nr)	(0x20 + (nr) * 2)
 #define F75375_REG_VOLT_LOW(nr)		(0x21 + (nr) * 2)
@@ -73,6 +87,8 @@ enum chips { f75373, f75375, f75387 };
 #define FAN_CTRL_MODE(nr)		(4 + ((nr) * 2))
 #define F75387_FAN_DUTY_MODE(nr)	(2 + ((nr) * 4))
 #define F75387_FAN_MANU_MODE(nr)	((nr) * 4)
+#define FAN_START_RPM 7000
+#define FAN_STOP_RPM 1
 
 /*
  * Data structures and manipulation thereof
@@ -109,6 +125,11 @@ struct f75375_data {
 	s16 temp11[2];
 	s8 temp_high[2];
 	s8 temp_max_hyst[2];
+	bool force_pwm_mode;
+	u32 enable_fan_fault;
+	u32 enable_temp_fault;
+	u32 pin5_mode;
+	u32 pin6_mode;
 };
 
 static int f75375_detect(struct i2c_client *client,
@@ -116,6 +137,7 @@ static int f75375_detect(struct i2c_client *client,
 static int f75375_probe(struct i2c_client *client,
 			const struct i2c_device_id *id);
 static int f75375_remove(struct i2c_client *client);
+static void f75375_shutdown(struct i2c_client *client);
 
 static const struct i2c_device_id f75375_id[] = {
 	{ "f75373", f75373 },
@@ -135,6 +157,7 @@ static struct i2c_driver f75375_driver = {
 	.id_table = f75375_id,
 	.detect = f75375_detect,
 	.address_list = normal_i2c,
+	.shutdown = f75375_shutdown,
 };
 
 static inline int f75375_read8(struct i2c_client *client, u8 reg)
@@ -750,15 +773,79 @@ static const struct attribute_group f75375_group = {
 	.attrs = f75375_attributes,
 };
 
+static void f75375_probe_of(struct i2c_client *client)
+{
+	struct device *dev = &client->dev;
+	struct f75375_data *data = i2c_get_clientdata(client);
+	int ret;
+
+	data->force_pwm_mode = of_property_read_bool(dev->of_node, "force-pwm-mode-3");
+	if (data->force_pwm_mode)
+		dev_info(dev, "enable force_pwm_mode\n");
+
+	ret = of_property_read_u32(dev->of_node, "pin5-mode",
+		&data->pin5_mode);
+	if (ret) {
+		dev_info(dev, "pin5-mode default disable\n");
+		data->pin5_mode = 0;
+	}
+
+	ret = of_property_read_u32(dev->of_node, "pin6-mode",
+		&data->pin6_mode);
+	if (ret) {
+		dev_info(dev, "pin6-mode default disable\n");
+		data->pin6_mode = 0;
+	}
+
+	ret = of_property_read_u32(dev->of_node, "enable_fan_fault",
+		&data->enable_fan_fault);
+	if (ret) {
+		dev_info(dev, "enable_fan_fault use default\n");
+		data->enable_fan_fault = 0;
+	}
+
+	ret = of_property_read_u32(dev->of_node, "enable_temp_fault",
+		&data->enable_temp_fault);
+	if (ret) {
+		dev_info(dev, "enable_temp_fault default disable\n");
+		data->enable_temp_fault = 0;
+	}
+}
+
+int manu_adjust_rpm(struct i2c_client *client, int rpm)
+{
+	struct f75375_data *data = i2c_get_clientdata(client);
+	int err;
+	u8 nr;
+
+	/* manual, speed */
+	f75375_probe_of(client);
+
+	if (data->force_pwm_mode > 0) {
+		for (nr = 0; nr < 2; nr++) {
+			data->pwm_mode[nr] = 1;
+			data->pwm_enable[nr] = 3;
+			err = set_pwm_enable_direct(client, nr, 3);
+			if (err) {
+				dev_err(&client->dev, "set_pwm_enable_direct fail\n");
+				return -EINVAL;
+			}
+
+			data->fan_target[nr] = rpm_to_reg(rpm);
+			f75375_write16(client, F75375_REG_FAN_EXP(nr), data->fan_target[nr]);
+		}
+	}
+
+	return 0;
+}
+
 static void f75375_init(struct i2c_client *client, struct f75375_data *data,
 		struct f75375s_platform_data *f75375s_pdata)
 {
-	int nr;
+	int nr, err;
+	u8 conf, mode;
 
 	if (!f75375s_pdata) {
-		u8 conf, mode;
-		int nr;
-
 		conf = f75375_read8(client, F75375_REG_CONFIG1);
 		mode = f75375_read8(client, F75375_REG_FAN_TIMER);
 		for (nr = 0; nr < 2; nr++) {
@@ -799,6 +886,64 @@ static void f75375_init(struct i2c_client *client, struct f75375_data *data,
 				}
 			}
 		}
+
+#ifdef CONFIG_OF
+		f75375_probe_of(client);
+
+		/* manual, speed */
+		if (data->force_pwm_mode > 0) {
+			err = manu_adjust_rpm(client, FAN_START_RPM);
+			if (err)
+				dev_err(&client->dev, "manu_adjust_rpm fail\n");
+		}
+
+		/*
+		 * Configuration Register
+		 * pin5 is used as Fan fault function
+		 * 00: pin5 function is GPIO2.(default)
+		 * 01: pin5 is used as SMI
+		 * 10: pin5 is used as Fan fault function
+		 * 11: LED out(1Hz/0.5Hz select by LED_FREQ register)
+		 */
+		conf = f75375_read8(client, F75375_REG_CONFIG2);
+		conf &= ~(CONFIG2_PIN5_MODE_MASK << CONFIG2_PIN5_MODE);
+		conf |= (data->pin5_mode << CONFIG2_PIN5_MODE);
+		f75375_write8(client, F75375_REG_CONFIG2, conf);
+
+		/*
+		 * Configuration Register
+		 * pin6 is used as Fan fault function
+		 * 00: PIN6 will act as GPIO3.
+		 * 01: PIN6 will act as OVT#
+		 * 10: PIN6 will act as voltage fault function
+		 * 11: PIN6 will function as operating clock input function
+		 */
+		conf = f75375_read8(client, F75375_REG_CONFIG3);
+		conf &= ~(CONFIG3_PIN6_MODE_MASK << CONFIG3_PIN6_MODE);
+		conf |= (data->pin6_mode << CONFIG3_PIN6_MODE);
+		f75375_write8(client, F75375_REG_CONFIG3, conf);
+		pr_info("F75375_REG_CONFIG3 0x%x\n", f75375_read8(client, F75375_REG_CONFIG3));
+
+		/*
+		 * REAL TIME Fault Status Register 1  Index 36h
+		 * bit 7 : EN_FAN2_FAULT, Enable fan fault mechanism of FAN2
+		 * bit 6 : EN_FAN1_FAULT, Enable fan fault mechanism of FAN1
+		 */
+		conf = f75375_read8(client, F75387_REG_REAL_TIME_FAULT_SAT);
+		conf &= ~(FAN_FAULT_MECH_MASK << FAN_FAULT_MECH_OFF);
+		conf |= (data->enable_fan_fault << FAN_FAULT_MECH_OFF);
+		f75375_write8(client, F75387_REG_REAL_TIME_FAULT_SAT, conf);
+
+		/*
+		 * REAL TIME Fault Status Register 1  Index 36h
+		 * bit 5 : Enable over temperature mechanism of VT2
+		 * bit 4 : Enable over temperature mechanism of VT1.
+		 */
+		conf = f75375_read8(client, F75387_REG_REAL_TIME_FAULT_SAT);
+		conf &= ~(TEMP_FAULT_MECH_MASK << TEMP_FAULT_MECH_OFF);
+		conf |= (data->enable_temp_fault << TEMP_FAULT_MECH_OFF);
+		f75375_write8(client, F75387_REG_REAL_TIME_FAULT_SAT, conf);
+#endif
 		return;
 	}
 
@@ -833,7 +978,11 @@ static int f75375_probe(struct i2c_client *client,
 	i2c_set_clientdata(client, data);
 	mutex_init(&data->update_lock);
 	data->kind = id->driver_data;
-
+	data->force_pwm_mode = -1;
+	data->enable_fan_fault = 0;
+	data->enable_temp_fault = 0;
+	data->pin5_mode = 0;
+	data->pin6_mode = 0;
 	err = sysfs_create_group(&client->dev.kobj, &f75375_group);
 	if (err)
 		return err;
@@ -858,7 +1007,6 @@ static int f75375_probe(struct i2c_client *client,
 	}
 
 	f75375_init(client, data, f75375s_pdata);
-
 	return 0;
 
 exit_remove:
@@ -904,6 +1052,21 @@ static int f75375_detect(struct i2c_client *client,
 	return 0;
 }
 
+static void f75375_shutdown(struct i2c_client *client)
+{
+	struct f75375_data *data = i2c_get_clientdata(client);
+	int err;
+
+#ifdef CONFIG_OF
+	/* manual, speed */
+	f75375_probe_of(client);
+	if (data->force_pwm_mode) {
+		err = manu_adjust_rpm(client, FAN_STOP_RPM);
+		if (err)
+			dev_err(&client->dev, "manu_adjust_rpm fail\n");
+	}
+#endif
+}
 module_i2c_driver(f75375_driver);
 
 MODULE_AUTHOR("Riku Voipio");
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index fba3965a8..dd96052bb 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -474,6 +474,14 @@ config XILINX_SDFEC
 
 	  If unsure, say N.
 
+config FINTEK_F81439
+	tristate "Fintek F81439 Control Driver"
+	help
+	  The F81439A is programmable, monolithic multi-protocol transceiver
+	  device that contains RS-232 and RS-485 / RS-422 drivers and receivers.
+
+	  If unsure, say N.
+
 config MISC_RTSX
 	tristate
 	default MISC_RTSX_PCI || MISC_RTSX_USB
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index d0e772f8e..8f41a13c5 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -59,3 +59,4 @@ obj-y				+= cardreader/
 obj-$(CONFIG_PVPANIC)   	+= pvpanic.o
 obj-$(CONFIG_HABANA_AI)		+= habanalabs/
 obj-$(CONFIG_XILINX_SDFEC)	+= xilinx_sdfec.o
+obj-$(CONFIG_FINTEK_F81439)	+= f81439_ctrl.o
diff --git a/drivers/misc/f81439_ctrl.c b/drivers/misc/f81439_ctrl.c
new file mode 100644
index 000000000..8f839af8c
--- /dev/null
+++ b/drivers/misc/f81439_ctrl.c
@@ -0,0 +1,252 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Description:
+ * The F81439 Control Driveris programmable, monolithic multi-protocol
+ * transceiver device that contains RS-232 and RS-485 / RS-422
+ * drivers and receivers
+ *
+ * slash.huang@dfi.com
+ * slash.linux.c@gmail.com
+ */
+
+#include <linux/miscdevice.h>
+#include <linux/io.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/poll.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#include <linux/gpio/consumer.h>
+
+#define DEV_NAME_LEN 12
+#define F81439_MODE_N 3
+
+struct f81439_ctl_dev {
+	struct miscdevice miscdev;
+	struct attribute_group attrs;
+	char dev_name[DEV_NAME_LEN];
+	struct device *dev;
+	spinlock_t gpio_lock;
+	struct gpio_desc *mode[F81439_MODE_N];
+	char current_mode[50];
+};
+
+enum {
+	F81439_MODE0 = 0,
+	F81439_MODE1,
+	F81439_MODE2,
+	F81439_MODE3,
+	F81439_MODE4,
+	F81439_MODE5,
+	F81439_MODE6,
+	F81439_MODE7,
+	F81439_MODE_END,
+};
+
+char mode_desrc[F81439_MODE_END][50] = {
+	{"rs422-full"},
+	{"pure-rs232"},
+	{"rs485-half tx-en low act"},
+	{"rs485-half tx-en hi  act"},
+	{"rs422-full rs485-half with termi bias resistor"},
+	{"pure-rs232 co-exists rs485"},
+	{"rs485-half with termi bias resistor"},
+	{"shutdown"},
+};
+
+void f81439_ctl_set_config(struct f81439_ctl_dev *f81439_ctl,
+	unsigned char set_mode)
+{
+	int i;
+
+	spin_lock(&f81439_ctl->gpio_lock);
+	for (i = 2; i >= 0; i--)
+		gpiod_set_value_cansleep(f81439_ctl->mode[i], set_mode >> i & 0x01);
+	spin_unlock(&f81439_ctl->gpio_lock);
+
+	sprintf(f81439_ctl->current_mode, "mode %d : %s", set_mode,
+		&mode_desrc[set_mode][0]);
+}
+
+static int f81439_ctl_parse_of(struct f81439_ctl_dev *f81439_ctl)
+{
+	struct device *dev = f81439_ctl->dev;
+	struct device_node *node = dev->of_node;
+	int rval, i;
+	const char *default_mode;
+
+	rval = of_property_read_string(node, "default-mode", &default_mode);
+	if (rval < 0) {
+		dev_info(dev, "not set default mode, prue rs232 mode\n");
+		f81439_ctl_set_config(f81439_ctl, F81439_MODE1);
+		return 0;
+	}
+
+	for (i = F81439_MODE0; i < F81439_MODE_END; i++) {
+		if (!strcmp(default_mode, &mode_desrc[i][0])) {
+			f81439_ctl_set_config(f81439_ctl, i);
+			return 0;
+		}
+	}
+
+	if (i >= F81439_MODE_END) {
+		dev_info(dev, "can't find mode, use prue rs232 mode\n");
+		f81439_ctl_set_config(f81439_ctl, F81439_MODE1);
+	}
+
+	return 0;
+}
+
+static ssize_t f81439_mode_store(struct device *dev, struct device_attribute *attr,
+	    const char *buf, size_t count)
+{
+	struct f81439_ctl_dev *f81439_ctl = dev_get_drvdata(dev);
+	unsigned char set_mode;
+	int ret;
+
+	if (set_mode < F81439_MODE0 && set_mode > F81439_MODE7)
+		return -EINVAL;
+
+	ret = kstrtou8(buf, 10, &set_mode);
+	if (ret < 0) {
+		dev_err(dev, "f81439_mode_store: value fail\n");
+		return ret;
+	}
+
+	f81439_ctl_set_config(f81439_ctl, set_mode);
+
+	return count;
+}
+
+static ssize_t f81439_mode_show(struct device *dev,
+				   struct device_attribute *devattr,
+				   char *buf)
+{
+	struct f81439_ctl_dev *f81439_ctl = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%s\n", f81439_ctl->current_mode);
+}
+
+static DEVICE_ATTR_RW(f81439_mode);
+
+static struct attribute *f81439_ctl_attributes[] = {
+	&dev_attr_f81439_mode.attr,
+	NULL
+};
+
+static const struct attribute_group f81439_ctl_attr_group = {
+	.attrs = f81439_ctl_attributes,
+};
+
+static int f81439_ctl_probe(struct platform_device *pdev)
+{
+	struct f81439_ctl_dev *f81439_ctl;
+	struct device *dev;
+	int err, i, index_mode;
+	char pin_name[5];
+
+	f81439_ctl = devm_kzalloc(&pdev->dev,
+		sizeof(struct f81439_ctl_dev), GFP_KERNEL);
+	if (!f81439_ctl)
+		return -ENOMEM;
+
+	f81439_ctl->dev = &pdev->dev;
+	dev = f81439_ctl->dev;
+
+	/*
+	 * MODE2_PIN -> f81439_ctl->mode[0]
+	 * MODE1_PIN -> f81439_ctl->mode[1]
+	 * MODE0_PIN -> f81439_ctl->mode[2]
+	 */
+	index_mode = 2;
+	for (i = 0; i <F81439_MODE_N; i++) {
+		sprintf(pin_name, "mode%d", index_mode);
+		f81439_ctl->mode[i] = devm_gpiod_get(dev, pin_name, GPIOD_OUT_HIGH);
+		if (IS_ERR(f81439_ctl->mode[i])) {
+			dev_err(dev, "mode-%d gpio get fail\n", i);
+			return PTR_ERR(f81439_ctl->mode[i]);
+		}
+		index_mode--;
+	}
+
+	spin_lock_init(&f81439_ctl->gpio_lock);
+
+	err = f81439_ctl_parse_of(f81439_ctl);
+	if (err < 0)
+		goto err_f81439_ctl_dev;
+
+	platform_set_drvdata(pdev, f81439_ctl);
+
+	snprintf(f81439_ctl->dev_name, DEV_NAME_LEN, "f81439_ctl");
+
+	f81439_ctl->miscdev.minor = MISC_DYNAMIC_MINOR;
+	f81439_ctl->miscdev.name = f81439_ctl->dev_name;
+	f81439_ctl->miscdev.parent = dev;
+	err = misc_register(&f81439_ctl->miscdev);
+	if (err) {
+		dev_err(dev, "error:%d. Unable to register device", err);
+		goto err_f81439_ctl_dev;
+	}
+
+	err = sysfs_create_group(&f81439_ctl->dev->kobj, &f81439_ctl_attr_group);
+	if (err)
+		goto err_f81439_ctl_dev;
+
+	return 0;
+
+err_f81439_ctl_dev:
+	return err;
+}
+
+static int f81439_ctl_remove(struct platform_device *pdev)
+{
+	struct f81439_ctl_dev *f81439_ctl;
+
+	f81439_ctl = platform_get_drvdata(pdev);
+	sysfs_remove_group(&pdev->dev.kobj, &f81439_ctl_attr_group);
+	misc_deregister(&f81439_ctl->miscdev);
+	return 0;
+}
+
+static const struct of_device_id f81439_ctl_of_match[] = {
+	{
+		.compatible = "fintek, f81439",
+	},
+	{ /* end of table */ }
+};
+MODULE_DEVICE_TABLE(of, f81439_ctl_of_match);
+
+static struct platform_driver f81439_ctl_driver = {
+	.driver = {
+		.name = "f81439-ctl",
+		.of_match_table = f81439_ctl_of_match,
+	},
+	.probe = f81439_ctl_probe,
+	.remove =  f81439_ctl_remove,
+};
+
+static int __init f81439_ctl_init(void)
+{
+	int err;
+
+	err = platform_driver_register(&f81439_ctl_driver);
+	if (err < 0) {
+		pr_err("%s Unabled to register f81439_ctl driver", __func__);
+		return err;
+	}
+	return 0;
+}
+
+static void __exit f81439_ctl_exit(void)
+{
+	platform_driver_unregister(&f81439_ctl_driver);
+}
+
+module_init(f81439_ctl_init);
+module_exit(f81439_ctl_exit);
+
+MODULE_AUTHOR("slash.linux.c@gmail.com");
+MODULE_DESCRIPTION("F81439 Control Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac-imx.c b/drivers/net/ethernet/stmicro/stmmac/dwmac-imx.c
index f86d24af3..1347bdb78 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac-imx.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-imx.c
@@ -22,6 +22,7 @@
 #include <linux/slab.h>
 #include <linux/stmmac.h>
 
+#include <linux/if_ether.h>
 #include "stmmac_platform.h"
 
 #ifdef CONFIG_IMX_SCU_SOC
@@ -37,6 +38,8 @@
 #define GPR_ENET_QOS_CLK_TX_CLK_SEL	(0x1 << 20)
 #define GPR_ENET_QOS_RGMII_EN		(0x1 << 21)
 
+u8 par_macaddr[ETH_ALEN];
+
 struct imx_dwmac_ops {
 	u32 addr_width;
 	bool mac_txclk_auto_adj;
@@ -280,9 +283,28 @@ imx_dwmac_parse_dt(struct imx_priv_data *dwmac, struct device *dev)
 		}
 	}
 
+	if (of_get_property(np, "stmmc-disable-dma-swrst", NULL))
+		dwmac->plat_dat->disable_dma_swrst = 1;
+	else
+		dwmac->plat_dat->disable_dma_swrst = 0;
+
 	return err;
 }
 
+static int __init ethaddr_cmdline_opt(char *str)
+{
+       int i;
+
+       i = sscanf(str, "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx",
+               &par_macaddr[0], &par_macaddr[1], &par_macaddr[2],
+               &par_macaddr[3], &par_macaddr[4], &par_macaddr[5]);
+
+       if (i != ETH_ALEN)
+               pr_err("smsc75xx set ethaddr error\r\n");
+
+       return 0;
+}
+
 static int imx_dwmac_probe(struct platform_device *pdev)
 {
 	struct plat_stmmacenet_data *plat_dat;
@@ -303,6 +325,7 @@ static int imx_dwmac_probe(struct platform_device *pdev)
 	if (IS_ERR(plat_dat))
 		return PTR_ERR(plat_dat);
 
+	stmmac_res.mac = par_macaddr;
 	data = of_device_get_match_data(&pdev->dev);
 	if (!data) {
 		dev_err(&pdev->dev, "failed to get match data\n");
@@ -313,6 +336,7 @@ static int imx_dwmac_probe(struct platform_device *pdev)
 	dwmac->ops = data;
 	dwmac->dev = &pdev->dev;
 
+	dwmac->plat_dat = plat_dat;
 	ret = imx_dwmac_parse_dt(dwmac, &pdev->dev);
 	if (ret) {
 		dev_err(&pdev->dev, "failed to parse OF data\n");
@@ -326,11 +350,11 @@ static int imx_dwmac_probe(struct platform_device *pdev)
 		goto err_dma_mask;
 	}
 
-	plat_dat->init = imx_dwmac_init;
-	plat_dat->exit = imx_dwmac_exit;
-	plat_dat->fix_mac_speed = imx_dwmac_fix_speed;
-	plat_dat->bsp_priv = dwmac;
-	dwmac->plat_dat = plat_dat;
+	dwmac->plat_dat->init = imx_dwmac_init;
+	dwmac->plat_dat->exit = imx_dwmac_exit;
+	dwmac->plat_dat->fix_mac_speed = imx_dwmac_fix_speed;
+	dwmac->plat_dat->bsp_priv = dwmac;
+
 
 	/* enable runtime pm to turn off power domain when netif down */
 	pm_runtime_enable(&pdev->dev);
@@ -356,6 +380,8 @@ static int imx_dwmac_probe(struct platform_device *pdev)
 	return ret;
 }
 
+__setup("ethaddr_eqos=", ethaddr_cmdline_opt);
+
 int imx_dwmac_remove(struct platform_device *pdev)
 {
 	pm_runtime_disable(&pdev->dev);
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
index a19c9c612..3195376df 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
@@ -2230,10 +2230,12 @@ static int stmmac_init_dma_engine(struct stmmac_priv *priv)
 	if (priv->extend_desc && (priv->mode == STMMAC_RING_MODE))
 		atds = 1;
 
-	ret = stmmac_reset(priv, priv->ioaddr);
-	if (ret) {
-		dev_err(priv->device, "Failed to reset the dma\n");
-		return ret;
+	if (!priv->plat->disable_dma_swrst) {
+		ret = stmmac_reset(priv, priv->ioaddr);
+		if (ret) {
+			dev_err(priv->device, "Failed to reset the dma\n");
+			return ret;
+		}
 	}
 
 	/* DMA Configuration */
diff --git a/drivers/net/usb/Kconfig b/drivers/net/usb/Kconfig
index 05bdcc591..c6c4955f3 100644
--- a/drivers/net/usb/Kconfig
+++ b/drivers/net/usb/Kconfig
@@ -540,6 +540,22 @@ config USB_NET_QMI_WWAN
 	  To compile this driver as a module, choose M here: the
 	  module will be called qmi_wwan.
 
+config USB_NET_SIMCOM_LTE_5G
+	tristate "SIMCOM 5G and LTE modems"
+	depends on USB_USBNET
+	select USB_WDM
+	help
+	  Support WWAN LTE/5G devices based on Qualcomm Mobile Data Modem
+	  (MDM) chipsets.  Examples of SIM8200
+
+	  This driver will only drive the ethernet part of the chips.
+	  The devices require additional configuration to be usable.
+	  Multiple management interfaces with linux drivers are
+	  available:
+
+	    * option: AT commands on /dev/ttyUSBx
+	    * cdc-wdm: Qualcomm MSM Interface (QMI) protocol on /dev/cdc-wdmx
+
 config USB_HSO
 	tristate "Option USB High Speed Mobile Devices"
 	depends on USB && RFKILL && TTY
diff --git a/drivers/net/usb/Makefile b/drivers/net/usb/Makefile
index 99fd12be2..4b138e903 100644
--- a/drivers/net/usb/Makefile
+++ b/drivers/net/usb/Makefile
@@ -38,6 +38,7 @@ obj-$(CONFIG_USB_NET_CDC_NCM)	+= cdc_ncm.o
 obj-$(CONFIG_USB_NET_HUAWEI_CDC_NCM)	+= huawei_cdc_ncm.o
 obj-$(CONFIG_USB_VL600)		+= lg-vl600.o
 obj-$(CONFIG_USB_NET_QMI_WWAN)	+= qmi_wwan.o
+obj-$(CONFIG_USB_NET_SIMCOM_LTE_5G)	+= qmi_wwan_simcom_1e0e_9001.o
 obj-$(CONFIG_USB_NET_CDC_MBIM)	+= cdc_mbim.o
 obj-$(CONFIG_USB_NET_CH9200)	+= ch9200.o
 obj-$(CONFIG_USB_NET_AQC111)	+= aqc111.o
diff --git a/drivers/net/usb/qmi_wwan_simcom_1e0e_9001.c b/drivers/net/usb/qmi_wwan_simcom_1e0e_9001.c
new file mode 100644
index 000000000..cbe06b1c3
--- /dev/null
+++ b/drivers/net/usb/qmi_wwan_simcom_1e0e_9001.c
@@ -0,0 +1,517 @@
+/*
+ * Copyright (c) 2012  Bjrn Mork <bjorn@mork.no>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ */
+
+#include <linux/version.h>
+#include <linux/etherdevice.h>
+#include <linux/ethtool.h>
+#include <linux/mii.h>
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/usb.h>
+#include <linux/usb/usbnet.h>
+#include <linux/usb/cdc.h>
+#include <linux/usb/cdc-wdm.h>
+
+
+/* The name of the CDC Device Management driver */
+#define DM_DRIVER "cdc_wdm"
+
+/*
+ * This driver supports wwan (3G/LTE/?) devices using a vendor
+ * specific management protocol called Qualcomm MSM Interface (QMI) -
+ * in addition to the more common AT commands over serial interface
+ * management
+ *
+ * QMI is wrapped in CDC, using CDC encapsulated commands on the
+ * control ("master") interface of a two-interface CDC Union
+ * resembling standard CDC ECM.  The devices do not use the control
+ * interface for any other CDC messages.  Most likely because the
+ * management protocol is used in place of the standard CDC
+ * notifications NOTIFY_NETWORK_CONNECTION and NOTIFY_SPEED_CHANGE
+ *
+ * Handling a protocol like QMI is out of the scope for any driver.
+ * It can be exported as a character device using the cdc-wdm driver,
+ * which will enable userspace applications ("modem managers") to
+ * handle it.  This may be required to use the network interface
+ * provided by the driver.
+ *
+ * These devices may alternatively/additionally be configured using AT
+ * commands on any of the serial interfaces driven by the option driver
+ *
+ * This driver binds only to the data ("slave") interface to enable
+ * the cdc-wdm driver to bind to the control interface.  It still
+ * parses the CDC functional descriptors on the control interface to
+ *  a) verify that this is indeed a handled interface (CDC Union
+ *     header lists it as slave)
+ *  b) get MAC address and other ethernet config from the CDC Ethernet
+ *     header
+ *  c) enable user bind requests against the control interface, which
+ *     is the common way to bind to CDC Ethernet Control Model type
+ *     interfaces
+ *  d) provide a hint to the user about which interface is the
+ *     corresponding management interface
+ *
+ *  For SIM8200 5G, modify by Slash.huang (slash.huang@dfi.com)
+ */
+
+/* using a counter to merge subdriver requests with our own into a combined state */
+static int qmi_wwan_manage_power(struct usbnet *dev, int on)
+{
+    atomic_t *pmcount = (void *)&dev->data[1];
+    int rv = 0;
+
+    dev_dbg(&dev->intf->dev, "%s() pmcount=%d, on=%d\n", __func__, atomic_read(pmcount), on);
+
+    if ((on && atomic_add_return(1, pmcount) == 1) || (!on && atomic_dec_and_test(pmcount))) {
+        /* need autopm_get/put here to ensure the usbcore sees the new value */
+        rv = usb_autopm_get_interface(dev->intf);
+
+        if (rv < 0)
+            goto err;
+
+        dev->intf->needs_remote_wakeup = on;
+        usb_autopm_put_interface(dev->intf);
+    }
+
+err:
+    return rv;
+}
+
+static int qmi_wwan_cdc_wdm_manage_power(struct usb_interface *intf, int on)
+{
+    struct usbnet *dev = usb_get_intfdata(intf);
+    return qmi_wwan_manage_power(dev, on);
+}
+
+/* Some devices combine the "control" and "data" functions into a
+ * single interface with all three endpoints: interrupt + bulk in and
+ * out
+ *
+ * Setting up cdc-wdm as a subdriver owning the interrupt endpoint
+ * will let it provide userspace access to the encapsulated QMI
+ * protocol without interfering with the usbnet operations.
+  */
+static int qmi_wwan_bind_shared(struct usbnet *dev, struct usb_interface *intf)
+{
+    int rv;
+    struct usb_driver *subdriver = NULL;
+    atomic_t *pmcount = (void *)&dev->data[1];
+
+    /* ZTE makes devices where the interface descriptors and endpoint
+     * configurations of two or more interfaces are identical, even
+     * though the functions are completely different.  If set, then
+     * driver_info->data is a bitmap of acceptable interface numbers
+     * allowing us to bind to one such interface without binding to
+     * all of them
+     */
+    if (dev->driver_info->data &&
+        !test_bit(intf->cur_altsetting->desc.bInterfaceNumber, &dev->driver_info->data)) {
+        dev_info(&intf->dev, "not on our whitelist - ignored");
+        rv = -ENODEV;
+        goto err;
+    }
+
+    atomic_set(pmcount, 0);
+
+    /* collect all three endpoints */
+    rv = usbnet_get_endpoints(dev, intf);
+
+    if (rv < 0)
+        goto err;
+
+    /* require interrupt endpoint for subdriver */
+    if (!dev->status) {
+        rv = -EINVAL;
+        goto err;
+    }
+
+    subdriver = usb_cdc_wdm_register(intf, &dev->status->desc, 512, &qmi_wwan_cdc_wdm_manage_power);
+
+    if (IS_ERR(subdriver)) {
+        rv = PTR_ERR(subdriver);
+        goto err;
+    }
+
+    /* can't let usbnet use the interrupt endpoint */
+    dev->status = NULL;
+
+    /* save subdriver struct for suspend/resume wrappers */
+    dev->data[0] = (unsigned long)subdriver;
+
+err:
+    return rv;
+}
+
+/* Gobi devices uses identical class/protocol codes for all interfaces regardless
+ * of function. Some of these are CDC ACM like and have the exact same endpoints
+ * we are looking for. This leaves two possible strategies for identifying the
+ * correct interface:
+ *   a) hardcoding interface number, or
+ *   b) use the fact that the wwan interface is the only one lacking additional
+ *      (CDC functional) descriptors
+ *
+ * Let's see if we can get away with the generic b) solution.
+ */
+static int qmi_wwan_bind_gobi(struct usbnet *dev, struct usb_interface *intf)
+{
+    int rv = -EINVAL;
+
+    /* ignore any interface with additional descriptors */
+    if (intf->cur_altsetting->extralen)
+        goto err;
+
+    rv = qmi_wwan_bind_shared(dev, intf);
+err:
+    return rv;
+}
+
+static void qmi_wwan_unbind_shared(struct usbnet *dev, struct usb_interface *intf)
+{
+    struct usb_driver *subdriver = (void *)dev->data[0];
+
+    if (subdriver && subdriver->disconnect)
+        subdriver->disconnect(intf);
+
+    dev->data[0] = (unsigned long)NULL;
+}
+
+/* suspend/resume wrappers calling both usbnet and the cdc-wdm
+ * subdriver if present.
+ *
+ * NOTE: cdc-wdm also supports pre/post_reset, but we cannot provide
+ * wrappers for those without adding usbnet reset support first.
+ */
+static int qmi_wwan_suspend(struct usb_interface *intf, pm_message_t message)
+{
+    struct usbnet *dev = usb_get_intfdata(intf);
+    struct usb_driver *subdriver = (void *)dev->data[0];
+    int ret;
+
+    ret = usbnet_suspend(intf, message);
+
+    if (ret < 0)
+        goto err;
+
+    if (subdriver && subdriver->suspend)
+        ret = subdriver->suspend(intf, message);
+
+    if (ret < 0)
+        usbnet_resume(intf);
+
+err:
+    return ret;
+}
+
+static int qmi_wwan_resume(struct usb_interface *intf)
+{
+    struct usbnet *dev = usb_get_intfdata(intf);
+    struct usb_driver *subdriver = (void *)dev->data[0];
+    int ret = 0;
+
+    if (subdriver && subdriver->resume)
+        ret = subdriver->resume(intf);
+
+    if (ret < 0)
+        goto err;
+
+    ret = usbnet_resume(intf);
+
+    if (ret < 0 && subdriver && subdriver->resume && subdriver->suspend)
+        subdriver->suspend(intf, PMSG_SUSPEND);
+
+err:
+    return ret;
+}
+
+/* SIMCOM SIM8200 */
+/* very simplistic detection of IPv4 or IPv6 headers */
+static bool possibly_iphdr(const char *data)
+{
+    return (data[0] & 0xd0) == 0x40;
+}
+
+/* SIMCOM devices combine the "control" and "data" functions into a
+ * single interface with all three endpoints: interrupt + bulk in and
+ * out
+ * sim7600dev->udev->descriptor.bcdDevice == cpu_to_le16(0x318)
+ * sim7100dev->udev->descriptor.bcdDevice == cpu_to_le16(0x232)
+ */
+static int simcom_wwan_bind_8200(struct usbnet *dev, struct usb_interface *intf)
+{
+    int rv = -EINVAL;
+
+    struct usb_driver *subdriver = NULL;
+    atomic_t *pmcount = (void *)&dev->data[1];
+
+    /* ignore any interface with additional descriptors */
+    if (intf->cur_altsetting->extralen)
+        goto err;
+
+    /* Some makes devices where the interface descriptors and endpoint
+     * configurations of two or more interfaces are identical, even
+     * though the functions are completely different.  If set, then
+     * driver_info->data is a bitmap of acceptable interface numbers
+     * allowing us to bind to one such interface without binding to
+     * all of them
+     */
+    if (dev->driver_info->data && !test_bit(intf->cur_altsetting->desc.bInterfaceNumber, &dev->driver_info->data)) {
+        dev_info(&intf->dev, "not on our whitelist - ignored");
+        rv = -ENODEV;
+        goto err;
+    }
+
+    atomic_set(pmcount, 0);
+
+    /* collect all three endpoints */
+    rv = usbnet_get_endpoints(dev, intf);
+
+    if (rv < 0)
+        goto err;
+
+    /* require interrupt endpoint for subdriver */
+    if (!dev->status) {
+        rv = -EINVAL;
+        goto err;
+    }
+
+    subdriver = usb_cdc_wdm_register(intf, &dev->status->desc, 512, &qmi_wwan_cdc_wdm_manage_power);
+
+    if (IS_ERR(subdriver)) {
+        rv = PTR_ERR(subdriver);
+        goto err;
+    }
+
+    /* can't let usbnet use the interrupt endpoint */
+    dev->status = NULL;
+
+    /* save subdriver struct for suspend/resume wrappers */
+    dev->data[0] = (unsigned long)subdriver;
+
+    /* can't let usbnet use the interrupt endpoint */
+    //dev->status = NULL;
+
+    printk("simcom usbnet bind here\n");
+
+    /*
+     * SIMCOM SIM7600 only support the RAW_IP mode, so the host net driver would
+     * remove the arp so the packets can transmit to the modem
+    */
+    dev->net->flags |= IFF_NOARP;
+
+    /* make MAC addr easily distinguishable from an IP header */
+    if (possibly_iphdr(dev->net->dev_addr)) {
+        dev->net->dev_addr[0] |= 0x02; /* set local assignment bit */
+        dev->net->dev_addr[0] &= 0xbf; /* clear "IP" bit */
+    }
+
+    /*
+     * SIMCOM SIM8200 need set line state
+    */
+    usb_control_msg(
+                    interface_to_usbdev(intf),
+                    usb_sndctrlpipe(interface_to_usbdev(intf), 0),
+                    0x22,                                           //USB_CDC_REQ_SET_CONTROL_LINE_STATE
+                    0x21,                                           //USB_DIR_OUT | USB_TYPE_CLASS| USB_RECIP_INTERFACE
+                    1,                                              //line state 1
+                    intf->cur_altsetting->desc.bInterfaceNumber,
+                    NULL, 0, 100);
+
+err:
+    return rv;
+}
+
+static int simcom_wwan_bind(struct usbnet *dev, struct usb_interface *intf)
+{
+    int ret = -EINVAL;
+
+    ret = simcom_wwan_bind_8200(dev, intf);
+
+    return ret;
+}
+
+static void simcom_wwan_unbind(struct usbnet *dev, struct usb_interface *intf)
+{
+    struct usb_driver *subdriver = (void *)dev->data[0];
+
+    if (dev->udev->descriptor.bcdDevice == cpu_to_le16(0x232)) {
+        return;
+    }
+
+    if (subdriver && subdriver->disconnect)
+        subdriver->disconnect(intf);
+
+    dev->data[0] = (unsigned long)NULL;
+}
+
+struct sk_buff *simcom_wwan_tx_fixup(struct usbnet *dev, struct sk_buff *skb, gfp_t flags)
+{
+    if (dev->udev->descriptor.bcdDevice == cpu_to_le16(0x232)) {
+        return skb;
+    }
+
+    /* skip ethernet header */
+    if (skb_pull(skb, ETH_HLEN))
+        return skb;
+    else
+        dev_err(&dev->intf->dev, "Packet Dropped\n");
+
+    if (skb != NULL)
+        dev_kfree_skb_any(skb);
+
+    return NULL;
+}
+
+static int simcom_wwan_rx_fixup(struct usbnet *dev, struct sk_buff *skb)
+{
+    __be16 proto;
+
+    if (dev->udev->descriptor.bcdDevice == cpu_to_le16(0x232))
+        return 1;
+
+    /* This check is no longer done by usbnet */
+    if (skb->len < dev->net->hard_header_len)
+        return 0;
+
+    switch (skb->data[0] & 0xf0) {
+        case 0x40:
+            printk("packetv4 coming ,,,\n");
+            proto = htons(ETH_P_IP);
+            break;
+
+        case 0x60:
+            printk("packetv6 coming ,,,\n");
+            proto = htons(ETH_P_IPV6);
+            break;
+
+        case 0x00:
+            printk("packet coming ,,,\n");
+
+            if (is_multicast_ether_addr(skb->data))
+                return 1;
+
+            /* possibly bogus destination - rewrite just in case */
+            skb_reset_mac_header(skb);
+            goto fix_dest;
+
+        default:
+            /* pass along other packets without modifications */
+            return 1;
+    }
+
+    if (skb_headroom(skb) < ETH_HLEN)
+        return 0;
+
+    skb_push(skb, ETH_HLEN);
+    skb_reset_mac_header(skb);
+    eth_hdr(skb)->h_proto = proto;
+    memset(eth_hdr(skb)->h_source, 0, ETH_ALEN);
+
+fix_dest:
+    memcpy(eth_hdr(skb)->h_dest, dev->net->dev_addr, ETH_ALEN);
+
+    return 1;
+}
+
+/* SIMCOM SIM8200 */
+static const struct driver_info qmi_wwan_gobi = {
+    .description    = "Qualcomm Gobi wwan/QMI device",
+    .flags          = FLAG_WWAN,
+    .bind           = qmi_wwan_bind_gobi,
+    .unbind         = qmi_wwan_unbind_shared,
+    .manage_power   = qmi_wwan_manage_power,
+};
+
+static const struct driver_info simcom_wwan_usbnet_driver_info = {
+    .description    = "SIMCOM wwan/QMI device",
+    .flags          = FLAG_WWAN,
+    .bind           = simcom_wwan_bind,
+    .unbind         = simcom_wwan_unbind,
+    .rx_fixup       = simcom_wwan_rx_fixup,
+    .tx_fixup       = simcom_wwan_tx_fixup,
+};
+
+/* Sierra Wireless provide equally useless interface descriptors
+ * Devices in QMI mode can be switched between two different
+ * configurations:
+ *   a) USB interface #8 is QMI/wwan
+ *   b) USB interfaces #8, #19 and #20 are QMI/wwan
+ *
+ * Both configurations provide a number of other interfaces (serial++),
+ * some of which have the same endpoint configuration as we expect, so
+ * a whitelist or blacklist is necessary.
+ *
+ * FIXME: The below whitelist should include BIT(20).  It does not
+ * because I cannot get it to work...
+ */
+static const struct driver_info qmi_wwan_sierra = {
+    .description    = "Sierra Wireless wwan/QMI device",
+    .flags          = FLAG_WWAN,
+    .bind           = qmi_wwan_bind_gobi,
+    .unbind         = qmi_wwan_unbind_shared,
+    .manage_power   = qmi_wwan_manage_power,
+    .data           = BIT(8) | BIT(19), /* interface whitelist bitmap */
+};
+
+#define HUAWEI_VENDOR_ID    0x12D1
+#define QMI_GOBI_DEVICE(vend, prod) \
+    USB_DEVICE(vend, prod), \
+    .driver_info = (unsigned long)&qmi_wwan_gobi
+
+static const struct usb_device_id products[] = {
+    {
+        /* SIM8200 Modem Device in QMI mode */
+        .match_flags = USB_DEVICE_ID_MATCH_DEVICE | USB_DEVICE_ID_MATCH_INT_INFO,
+        .idVendor = 0x1e0e,
+        .idProduct = 0x9001,
+        .bInterfaceClass = 0xff,
+        .bInterfaceSubClass = 0xff,
+        .bInterfaceProtocol = 0x50,
+        .driver_info = (unsigned long) &simcom_wwan_usbnet_driver_info,
+    },
+    {
+        /* SIM8200 Modem Device in QMI mode(legacy) */
+        .match_flags = USB_DEVICE_ID_MATCH_DEVICE | USB_DEVICE_ID_MATCH_INT_INFO,
+        .idVendor = 0x1e0e,
+        .idProduct = 0x9001,
+        .bInterfaceClass = 0xff,
+        .bInterfaceSubClass = 0xff,
+        .bInterfaceProtocol = 0xff,
+        .driver_info = (unsigned long) &simcom_wwan_usbnet_driver_info,
+    },
+    { QMI_GOBI_DEVICE(0x05c6, 0x9205) }, /* Gobi 2000 Modem device */
+    { QMI_GOBI_DEVICE(0x05c6, 0x9215) }, /* Gobi 2000 Modem device */
+    {} /* END */
+};
+MODULE_DEVICE_TABLE(usb, products);
+
+static struct usb_driver qmi_wwan_driver = {
+    .name                   = "qmi_wwan_simcom",
+    .id_table               = products,
+    .probe                  = usbnet_probe,
+    .disconnect             = usbnet_disconnect,
+    .suspend                = qmi_wwan_suspend,
+    .resume                 = qmi_wwan_resume,
+    .reset_resume           = qmi_wwan_resume,
+    .supports_autosuspend   = 1,
+};
+
+static int __init qmi_wwan_init(void)
+{
+    return usb_register(&qmi_wwan_driver);
+}
+module_init(qmi_wwan_init);
+
+static void __exit qmi_wwan_exit(void)
+{
+    usb_deregister(&qmi_wwan_driver);
+}
+module_exit(qmi_wwan_exit);
+
+MODULE_AUTHOR("xiaobin.wang@simcom.com");
+MODULE_DESCRIPTION("SIMCOM (QMI) WWAN driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/rtc/rtc-s35390a.c b/drivers/rtc/rtc-s35390a.c
index da34cfd70..78319651b 100644
--- a/drivers/rtc/rtc-s35390a.c
+++ b/drivers/rtc/rtc-s35390a.c
@@ -17,6 +17,7 @@
 #define S35390A_CMD_STATUS2	1
 #define S35390A_CMD_TIME1	2
 #define S35390A_CMD_TIME2	3
+#define S35390A_CMD_INT1_REG1	4
 #define S35390A_CMD_INT2_REG1	5
 
 #define S35390A_BYTE_YEAR	0
@@ -425,6 +426,52 @@ static const struct rtc_class_ops s35390a_rtc_ops = {
 
 static struct i2c_driver s35390a_driver;
 
+int of_property(struct i2c_client *client)
+{
+	struct device *dev = &client->dev;
+	struct s35390a *s35390a = i2c_get_clientdata(client);
+	u32 user_freq;
+	int err;
+	char buf[1];
+	#define INT1FE_OFF 8
+	#define USER_FREQ_OFF 4
+
+	err = of_property_read_u32(dev->of_node, "user-set-frequency",
+		&user_freq);
+	if (err) {
+		dev_info(dev, "user-set-frequency use default 1 Hz\n");
+		user_freq = 16;
+	}
+
+	err = s35390a_get_reg(s35390a, S35390A_CMD_STATUS2, buf, sizeof(buf));
+	if (err < 0) {
+		dev_err(dev, "s35390a_get_reg S35390A_CMD_STATUS2 fail\n");
+		return err;
+	}
+
+	buf[0] |= (1 << INT1FE_OFF);
+	err = s35390a_set_reg(s35390a, S35390A_CMD_STATUS2, buf, sizeof(buf));
+	if (err < 0) {
+		dev_err(dev, "s35390a_set_reg S35390A_CMD_STATUS2 fail\n");
+		return err;
+	}
+
+	err = s35390a_get_reg(s35390a, S35390A_CMD_INT1_REG1, buf, sizeof(buf));
+	if (err < 0) {
+		dev_err(dev, "s35390a_get_reg S35390A_CMD_INT1_REG1 fail\n");
+		return err;
+	}
+
+	buf[0] &= ~(0x1F << USER_FREQ_OFF);
+	buf[0] |= (user_freq << USER_FREQ_OFF);
+	err = s35390a_set_reg(s35390a, S35390A_CMD_INT1_REG1, buf, sizeof(buf));
+	if (err < 0) {
+		dev_err(dev, "s35390a_set_reg S35390A_CMD_INT1_REG1 fail\n");
+		return err;
+	}
+	return 0;
+}
+
 static int s35390a_probe(struct i2c_client *client,
 			 const struct i2c_device_id *id)
 {
@@ -497,6 +544,10 @@ static int s35390a_probe(struct i2c_client *client,
 	if (status1 & S35390A_FLAG_INT2)
 		rtc_update_irq(s35390a->rtc, 1, RTC_AF);
 
+	err = of_property(client);
+	if (err) {
+		dev_warn(dev, "of_property fail\n");
+	}
 	return 0;
 }
 
diff --git a/drivers/usb/roles/Kconfig b/drivers/usb/roles/Kconfig
index f8b31aa67..5117aeebb 100644
--- a/drivers/usb/roles/Kconfig
+++ b/drivers/usb/roles/Kconfig
@@ -26,4 +26,13 @@ config USB_ROLES_INTEL_XHCI
 	  To compile the driver as a module, choose M here: the module will
 	  be called intel-xhci-usb-role-switch.
 
+config M8MP553_USB_ROLES_SW
+	tristate "DFI M8MP553 USB Role Switch"
+	depends on USB_DWC3_IMX8MP
+	default y
+	help
+	  Driver for the internal USB role switch for switching the USB data
+	  lines between the xHCI host controller and the dwc3 gadget controller
+	  found on NXP IMX8MP.
+
 endif # USB_ROLE_SWITCH
diff --git a/drivers/usb/roles/Makefile b/drivers/usb/roles/Makefile
index 757a7d279..b59ecc8ad 100644
--- a/drivers/usb/roles/Makefile
+++ b/drivers/usb/roles/Makefile
@@ -3,3 +3,4 @@
 obj-$(CONFIG_USB_ROLE_SWITCH)		+= roles.o
 roles-y					:= class.o
 obj-$(CONFIG_USB_ROLES_INTEL_XHCI)	+= intel-xhci-usb-role-switch.o
+obj-$(CONFIG_M8MP553_USB_ROLES_SW)	+= m8mp553-role-switch.o
diff --git a/drivers/usb/roles/m8mp553-role-switch.c b/drivers/usb/roles/m8mp553-role-switch.c
new file mode 100644
index 000000000..b76b49ed2
--- /dev/null
+++ b/drivers/usb/roles/m8mp553-role-switch.c
@@ -0,0 +1,179 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Base on Intel XHCI (Cherry Trail, Broxton and others) USB OTG role switch driver
+ *
+ * Author: Slash.Huang
+ * slash.linux.c@gmail.com
+ */
+
+#include <linux/acpi.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/property.h>
+#include <linux/usb/role.h>
+#include <linux/gpio/consumer.h>
+
+#define DRV_NAME "m8mp553_otg_sw"
+
+struct m8mp553_otg_sw_data {
+	struct device *dev;
+	struct usb_role_switch *role_sw;
+	struct gpio_desc *gpio_role;
+	int irq;
+};
+
+static const struct software_node m8mp553_otg_sw_node = {
+	"m8mp553-xhci-usb-sw",
+};
+
+static enum usb_role otg_sw_get_role(struct m8mp553_otg_sw_data *data)
+{
+	enum usb_role role;
+	u32 val;
+
+	val = gpiod_get_value(data->gpio_role);
+
+	if (!val)
+		role = USB_ROLE_HOST;
+	else
+		role = USB_ROLE_DEVICE;
+
+	return role;
+}
+
+static irqreturn_t otg_sw_isr(int irq, void *dev_id)
+{
+	struct m8mp553_otg_sw_data *data;
+	int val;
+
+	data = (struct m8mp553_otg_sw_data *)dev_id;
+
+	val = gpiod_get_value(data->gpio_role);
+
+	if (!val)
+		usb_role_switch_set_role(data->role_sw, USB_ROLE_HOST);
+	else
+		usb_role_switch_set_role(data->role_sw, USB_ROLE_DEVICE);
+
+	return IRQ_HANDLED;
+}
+
+static int m8mp553_otg_sw_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct m8mp553_otg_sw_data *data;
+	char pin_name[5];
+	int ret, irq;
+	struct fwnode_handle *connector, *ep;
+	enum usb_role role;
+
+	data = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	data->dev = &pdev->dev;
+
+	sprintf(pin_name, "role");
+	data->gpio_role = devm_gpiod_get(dev, pin_name, GPIOD_IN);
+	if (IS_ERR(data->gpio_role)) {
+		dev_err(dev, "otg role switch gpio get fail\n");
+		return PTR_ERR(data->gpio_role);
+	}
+
+	irq = gpiod_to_irq(data->gpio_role);
+	data->irq = irq;
+
+	platform_set_drvdata(pdev, data);
+
+	/* For backward compatibility check the connector child node first */
+	connector = device_get_named_child_node(data->dev, "connector");
+	if (connector) {
+		data->role_sw = fwnode_usb_role_switch_get(connector);
+	} else {
+		ep = fwnode_graph_get_next_endpoint(dev_fwnode(data->dev), NULL);
+		if (!ep) {
+			dev_err(&pdev->dev, "can't fwnode_graph_get_next_endpoint\n");
+			goto irq_fail;
+		}
+
+		connector = fwnode_graph_get_remote_port_parent(ep);
+		fwnode_handle_put(ep);
+		if (!connector) {
+			dev_err(&pdev->dev, "can't find connector in dts\n");
+			goto irq_fail;
+		}
+
+		data->role_sw = usb_role_switch_get(data->dev);
+	}
+
+	if (IS_ERR(data->role_sw)) {
+		ret = PTR_ERR(data->role_sw);
+		goto err_put_fwnode;
+	}
+
+	role = otg_sw_get_role(data);
+	if (role == USB_ROLE_HOST)
+		usb_role_switch_set_role(data->role_sw, USB_ROLE_HOST);
+	else
+		usb_role_switch_set_role(data->role_sw, USB_ROLE_DEVICE);
+
+	/* Request IRQ */
+	ret = devm_request_irq(&pdev->dev, irq, otg_sw_isr,
+				IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING,
+				pdev->name, data);
+	if (ret) {
+		dev_err(&pdev->dev, "can't claim irq %d\n", irq);
+		goto irq_fail;
+	}
+
+	pm_runtime_set_active(dev);
+	pm_runtime_enable(dev);
+	return 0;
+
+err_put_fwnode:
+	fwnode_handle_put(connector);
+
+irq_fail:
+	kfree(data);
+
+	return -EINVAL;
+}
+
+static int m8mp553_otg_sw_remove(struct platform_device *pdev)
+{
+	struct m8mp553_otg_sw_data *data = platform_get_drvdata(pdev);
+
+	pm_runtime_disable(&pdev->dev);
+	usb_role_switch_unregister(data->role_sw);
+	kfree(data);
+	return 0;
+}
+
+static const struct of_device_id m8mp553_otg_sw_of_match[] = {
+	{
+		.compatible = "dfi, otg-sw",
+	},
+	{ /* end of table */ }
+};
+MODULE_DEVICE_TABLE(of, m8mp553_otg_sw_of_match);
+
+static struct platform_driver m8mp553_otg_sw_driver = {
+	.driver = {
+		.name = DRV_NAME,
+		.of_match_table = m8mp553_otg_sw_of_match,
+	},
+
+	.probe = m8mp553_otg_sw_probe,
+	.remove = m8mp553_otg_sw_remove,
+};
+
+module_platform_driver(m8mp553_otg_sw_driver);
+
+MODULE_AUTHOR("slash.huang <slash.huang@linux.c.com>");
+MODULE_DESCRIPTION("DFI USB3 role switch driver");
+MODULE_LICENSE("GPL");
diff --git a/include/linux/stmmac.h b/include/linux/stmmac.h
index a15818f3d..79fd5aeb8 100644
--- a/include/linux/stmmac.h
+++ b/include/linux/stmmac.h
@@ -192,5 +192,6 @@ struct plat_stmmacenet_data {
 	int mac_port_sel_speed;
 	bool en_tx_lpi_clockgating;
 	int has_xgmac;
+	int disable_dma_swrst;
 };
 #endif
diff --git a/sound/soc/codecs/sgtl5000.c b/sound/soc/codecs/sgtl5000.c
index e949b372c..f635b02db 100644
--- a/sound/soc/codecs/sgtl5000.c
+++ b/sound/soc/codecs/sgtl5000.c
@@ -773,7 +773,7 @@ static const struct snd_kcontrol_new sgtl5000_snd_controls[] = {
 	SOC_SINGLE_TLV("BASS 4", SGTL5000_DAP_EQ_BASS_BAND4,
 	0, 0x5F, 0, bass_band),
 };
-
+#ifdef ENABLE_DIGITAL_MUTE
 /* mute the codec used by alsa core */
 static int sgtl5000_digital_mute(struct snd_soc_dai *codec_dai, int mute)
 {
@@ -790,7 +790,7 @@ static int sgtl5000_digital_mute(struct snd_soc_dai *codec_dai, int mute)
 
 	return 0;
 }
-
+#endif
 /* set codec format */
 static int sgtl5000_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)
 {
@@ -1153,6 +1153,18 @@ static int sgtl5000_set_bias_level(struct snd_soc_component *component,
 	return 0;
 }
 
+int sgtl5000_startup(struct snd_pcm_substream *substream,
+	struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+void sgtl5000_shutdown(struct snd_pcm_substream *substream,
+	struct snd_soc_dai *dai)
+{
+}
+
+
 #define SGTL5000_FORMATS (SNDRV_PCM_FMTBIT_S16_LE |\
 			SNDRV_PCM_FMTBIT_S20_3LE |\
 			SNDRV_PCM_FMTBIT_S24_LE |\
@@ -1160,9 +1172,15 @@ static int sgtl5000_set_bias_level(struct snd_soc_component *component,
 
 static const struct snd_soc_dai_ops sgtl5000_ops = {
 	.hw_params = sgtl5000_pcm_hw_params,
+#ifdef ENABLE_DIGITAL_MUTE
 	.digital_mute = sgtl5000_digital_mute,
+#endif
 	.set_fmt = sgtl5000_set_dai_fmt,
 	.set_sysclk = sgtl5000_set_dai_sysclk,
+#ifdef ENABLE_START_UP_SHUTDOWN
+	.startup = sgtl5000_startup,
+	.shutdown = sgtl5000_shutdown,
+#endif
 };
 
 static struct snd_soc_dai_driver sgtl5000_dai = {
@@ -1596,7 +1614,7 @@ static int sgtl5000_i2c_probe(struct i2c_client *client,
 		goto disable_regs;
 	}
 
-	sgtl5000->mclk = devm_clk_get(&client->dev, NULL);
+	sgtl5000->mclk = devm_clk_get(&client->dev, "mclk");
 	if (IS_ERR(sgtl5000->mclk)) {
 		ret = PTR_ERR(sgtl5000->mclk);
 		/* Defer the probe to see if the clk will be provided later */
@@ -1702,10 +1720,12 @@ static int sgtl5000_i2c_probe(struct i2c_client *client,
 		}
 		if (!of_property_read_u32(np,
 			"micbias-voltage-m-volts", &value)) {
-			/* 1250mV => 0 */
-			/* steps of 250mV */
-			if ((value >= 1250) && (value <= 3000))
-				sgtl5000->micbias_voltage = (value / 250) - 5;
+			/* Document Number: SGTL5000 */
+			/* Rev. 6.0, 11/2013 */
+			/* 800mV => 0 */
+			/* steps of 25mV */
+			if ((value >= 800) && (value <= 1575))
+				sgtl5000->micbias_voltage = (value / 25);
 			else {
 				sgtl5000->micbias_voltage = 0;
 				dev_err(&client->dev,
diff --git a/sound/soc/fsl/fsl_sai.c b/sound/soc/fsl/fsl_sai.c
index 6508e2d2b..3a1b1ff97 100644
--- a/sound/soc/fsl/fsl_sai.c
+++ b/sound/soc/fsl/fsl_sai.c
@@ -481,7 +481,7 @@ static int fsl_sai_check_ver(struct device *dev)
 	if (ret < 0)
 		return ret;
 
-	dev_dbg(dev, "VERID: 0x%016X\n", val);
+	dev_info(dev, "VERID: 0x%016X\n", val);
 
 	sai->verid.id = (val & FSL_SAI_VER_ID_MASK) >> FSL_SAI_VER_ID_SHIFT;
 	sai->verid.extfifo_en = (val & FSL_SAI_VER_EFIFO_EN);
@@ -491,7 +491,7 @@ static int fsl_sai_check_ver(struct device *dev)
 	if (ret < 0)
 		return ret;
 
-	dev_dbg(dev, "PARAM: 0x%016X\n", val);
+	dev_info(dev, "PARAM: 0x%016X\n", val);
 
 	/* max slots per frame, power of 2 */
 	sai->param.spf = 1 <<
@@ -504,7 +504,7 @@ static int fsl_sai_check_ver(struct device *dev)
 	/* number of datalines implemented */
 	sai->param.dln = val & FSL_SAI_PAR_DLN_MASK;
 
-	dev_dbg(dev,
+	dev_info(dev,
 		"Version: 0x%08X, SPF: %u, WPF: %u, DLN: %u\n",
 		sai->verid.id, sai->param.spf, sai->param.wpf, sai->param.dln
 	);
@@ -1522,6 +1522,14 @@ static int fsl_sai_probe(struct platform_device *pdev)
 	    sai->verid.id >= FSL_SAI_VERID_0301) {
 		regmap_update_bits(sai->regmap, FSL_SAI_MCTL,
 				   FSL_SAI_MCTL_MCLK_EN, FSL_SAI_MCTL_MCLK_EN);
+
+		clk_prepare_enable(sai->bus_clk);
+		clk_prepare_enable(sai->mclk_clk[1]);
+		regmap_update_bits(sai->regmap, FSL_SAI_MCTL,
+			FSL_SAI_MCTL_MCLK_EN, FSL_SAI_MCTL_MCLK_EN);
+
+		regmap_update_bits(sai->regmap, FSL_SAI_TCSR(8),
+			FSL_SAI_CSR_TERE, FSL_SAI_CSR_TERE);
 	}
 
 	if (sai->verid.timestamp_en) {
